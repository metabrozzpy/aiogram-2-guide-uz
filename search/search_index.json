{"config":{"lang":["en","ru"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Xush kelibsiz!","text":"<p>Nega bu yangi kitob ? 2015 yilda kitobning birinchi talqini chiqqanidan beri Pythonda ham, Telegram(Bot API)da ham ko'p narsa o'zgardi. Ushbu kitobda biz aiogram va Telethon kutubxonalaridan foydalanib, botlar bilan bog'liq bir nechta qiziqarli yondashuvlarni ko'rib chiqamiz.</p> <p>Kitob kimlar uchun ? Siz dasturlash va xususan Pythonni yaxshi bilsangiz, \"venv\" va \"pip\" nima ekanligi, hamda SyntaxError va IndentationError kabi \"\u0434\u0435\u0442\u0441\u043a\u0438\u0439\" xatolarni tushunib, tuzatishga qodir bo'lsangiz davom etishingiz mumkin. Pythonga endigina kirib botlar yozishni boshlamang, basic darajada o'rganing, vaqtingizni va asab hujayralarini tejang.</p> <p>Atrof - muhit Barcha bo'limlarda biz GNU/Linux oilasidan operatsion tizim sifatida foydalanamiz, masalan, Ubuntu, Python 3.7 (Virtual muhitda) va dasturlash muhiti PyCharm Community Edition, ammo Visual Studio Code ishlatishga ham ruxsat. Shu bilan birga, Windows foydalanuvchilari xafa bo'lmang: kod bilan bog'liq hamma narsa sizda ham muammolarsiz ishlaydi, lekin systemd kabilarni Ubuntudan VirtualBoxda foydalanishingiz mumkin.</p> <p>P.S. (Muallifdan) Kitob matni va tegishli repodagi manbalar  butunlay bepul, MIT litsenziyasi ostida nashr etilgan va har kim yuklab olishi, o'zgartirishi va istalgan maqsadda foydalanishi mumkin. Agar siz muallifga moddiy rahmat aytmoqchi bo'lsangiz, buni \u042e.Money orqali donat qilish orqali bildirishingiz mumkin. (Iltimos, donat izohlarida bu kitob uchun ekanligini ko'rsating).</p> <p>P.S. (Tarjimondan) Yordam beradimi yo'qmi bilmayman, ammo mahalliylashtirishda ancha qiynaldim juda ko'p so'zlar ingliz va rus tilida tushunarli va o'zgarmasdek tuyildi, shungami bilmadim ularni o'z xolicha qoldirdim (tarjima qovushmayotgan bo'lsa asl talqinini o'qing!). Tarjimada xatolar bo'lsa bemalol repoga otib Pull Request yoki telegram guruhimizda @hoosnickga mention bering.  </p> <p>Manfaat keltirayotganiga bildirgi bersangiz, kitobning birinchi hamda yangilangan aiogram 3.x talqinini ham tarjima qilamiz.</p>"},{"location":"buttons/","title":"Tugmalar","text":"<p>Ushbu bobda biz Telegram botlarining tugmalar kabi ajoyib xususiyati bilan tanishamiz. Avvalo, chalkashmaslik uchun ularga nom beraylik. Qurilmangiz ekranining pastki qismiga yopishib olganlarni oddiy tugmalar, to\u2018g\u2018ridan-to\u2018g\u2018ri xabarlarga yopishib olganlarni esa inline tugmalar deb nomlaymiz. Yana bir bor rasmga:  </p> <p></p>"},{"location":"buttons/#reply-buttons","title":"Oddiy tugmalar","text":""},{"location":"buttons/#reply-as-text","title":"Shablon sifatidagi tugmalar","text":"<p>Ushbu turdagi tugma Bot APIga 2015 yilda paydo bo'lgan va oddiy matndan farqi yoq (bir nechta maxsus holatlar bundan mustasno, lekin ular haqida keyinroq). \u041f\u0440\u0438\u043d\u0446\u0438\u043f oddiy: tugmada yozilgan matn chatga yuboriladi va bot bosilgan tugmadagi matn bilan ishlovchi handlerga yuboradi. Foydalanuvchi tugma o'rniga tugmadagi matnni yozib yuborishi ham bosilganiga teng! Shuning uchun \"matn shablonlari\" deyishgan ya'ni pastdagi tugmalar aslida bular oddiy tayyor matnlar to'plami.</p> <p><code>/start</code> buyrug`i bosilganda ikkita tugma bilan xabar yuboradigan handler yozamiz:</p> <pre><code># from aiogram import types\n@dp.message_handler(commands=\"start\")\nasync def cmd_start(message: types.Message):\n    keyboard = types.ReplyKeyboardMarkup()\n    button_1 = types.KeyboardButton(text=\"\u0421 \u043f\u044e\u0440\u0435\u0448\u043a\u043e\u0439\")\n    keyboard.add(button_1)\n    button_2 = \"\u0411\u0435\u0437 \u043f\u044e\u0440\u0435\u0448\u043a\u0438\"\n    keyboard.add(button_2)\n    await message.answer(\"\u041a\u0430\u043a \u043f\u043e\u0434\u0430\u0432\u0430\u0442\u044c \u043a\u043e\u0442\u043b\u0435\u0442\u044b?\", reply_markup=keyboard)\n</code></pre> <p>E'tibor bering, oddiy tugmalar matn shablonlari bo'lganligi sababli, ular nafaqat <code>KeyboardButton</code> obyektlari, balki oddiy stringlar sifatida ham yaratilishi mumkin.  </p> <p>Keling, botni ishga tushiramiz va otni kallasidek keladigan tugmalardan hayratda qolamiz:</p> <p></p> <p>Qanaqadir juda xunuk. Birinchidan, men tugmalarni kichikroq qilishni, ikkinchidan, ularni gorizontal tartibga keltirishni xohlayman. Nima uchun ular juda katta? Gap shundaki, aslida \"tugma\" smartfon klaviaturasidagi oddiy alifbo kabi ko'proq joy egallashi kerak. Tugmalarni kichraytirish uchun siz <code>ReplyKeyboardMarkup</code> obyektiga qo'shimcha parametr <code>resize_keyboard=True</code> belgilashingiz kerak. Ammo vertikal tugmalarni gorizontallar bilan qanday almashtirish mumkin? Bot API nuqtai nazaridan keyboard bu tugmalardan iborat massivlar massivi yoki oddiyroq aytganda, qatorlar massividir. <code>add()</code> metodini har safar chaqirganda yangi qator hosil qiladi. Keling, chiroyli ko'rinishi uchun kodimizni qayta yozamiz:</p> <pre><code>@dp.message_handler(commands=\"start\")\nasync def cmd_start(message: types.Message):\n    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)\n    buttons = [\"\u0421 \u043f\u044e\u0440\u0435\u0448\u043a\u043e\u0439\", \"\u0411\u0435\u0437 \u043f\u044e\u0440\u0435\u0448\u043a\u0438\"]\n    keyboard.add(*buttons)\n    await message.answer(\"\u041a\u0430\u043a \u043f\u043e\u0434\u0430\u0432\u0430\u0442\u044c \u043a\u043e\u0442\u043b\u0435\u0442\u044b?\", reply_markup=keyboard)\n</code></pre> <p><code>*buttons</code> konstruktsiyasiga e'tibor bering. Bu C++ emas bu yulduzchadan ro'yxatni ochish uchun ishlatilinadi. <code>*</code> va <code>**</code> operatorlari haqida ko'proq ma`lumotni bu yerda o'qishingiz mumkin.</p> <p>Ko'ring - bu haqiqatan ham chiroyli:</p> <p></p> <p>Botni bunday tugmalarni bosganda javob berishga o'rgatish qoldi. Yuqorida aytib o'tilganidek, matnning to'liq mos kelishini tekshirish kerak. Buni ikki usulda bajarishimiz mumkin: maxsus <code>Text</code> filtri yoki oddiy lambda orqali:</p> <pre><code># from aiogram.dispatcher.filters import Text\n@dp.message_handler(Text(equals=\"\u0421 \u043f\u044e\u0440\u0435\u0448\u043a\u043e\u0439\"))\nasync def with_puree(message: types.Message):\n    await message.reply(\"\u041e\u0442\u043b\u0438\u0447\u043d\u044b\u0439 \u0432\u044b\u0431\u043e\u0440!\")\n\n\n@dp.message_handler(lambda message: message.text == \"\u0411\u0435\u0437 \u043f\u044e\u0440\u0435\u0448\u043a\u0438\")\nasync def without_puree(message: types.Message):\n    await message.reply(\"\u0422\u0430\u043a \u043d\u0435\u0432\u043a\u0443\u0441\u043d\u043e!\")\n</code></pre> <p></p> <p>Matnli tugmalarni olib tashlash uchun siz <code>ReplyKeyboardRemove</code> maxsus \"o'chirish\" keyboardi bilan yangi xabar yuborishingiz kerak. Masalan: <code>await message.reply(\"\u041e\u0442\u043b\u0438\u0447\u043d\u044b\u0439 \u0432\u044b\u0431\u043e\u0440!\", reply_markup=types.ReplyKeyboardRemove())</code></p> <p>Oddiy keyboard obyekti (ReplyKeyboardMarkup)da yana ikkita foydali parametr mavjud: tugmalarni bosgandan keyin yashirish uchun <code>one_time_keyboard</code> va <code>selective</code> keyboardni guruhdagi ayrim a'zolariga ko'rsatish uchun. Ulardan foydalanish mustaqil o'rganish uchun qoldiriladi, o'zing ko'rib chiq \u043a\u0430\u0440\u043e\u0447\u0435.</p> <p>Yuqorida tavsiflangan standart parametrlarga qo'shimcha ravishda, aiogram <code>row_width</code> parametri bilan keyboardlarning funksionalligini biroz kengaytiradi. Undan foydalanilganda, aiogram avtomatik ravishda tugmalar massivini har biri N elementdan iborat qatorlarga ajratadi, bu erda N - <code>row_width</code> qiymati, masalan, <code>row_width=2</code>. Urunib ko'ring!</p>"},{"location":"buttons/#reply-special","title":"Maxsus tugmalar","text":"<p>Telegramda oddiy tugmalarning uchta maxsus turi mavjud: biri manzilni yuborish, ikkinchisi telefon raqamini yuborish va oxirgisi so\u2018rov/viktorina yaratish uchun. Dastlabki ikkita tur uchun mantiqiy(bool) qiymatni ko'rsatish kifoya (True/False), so'rovlar va viktorinalar uchun esa maxsus turdagi <code>KeyboardButtonPollType</code>dan o'tishingiz va ixtiyoriy ravishda yaratiladigan obyekt(quiz/poll) turini belgilashingiz kerak.</p> <p>Eng osoni, kodni bir marta ko'rish yaxshiroq: <pre><code>@dp.message_handler(commands=\"special_buttons\")\nasync def cmd_special_buttons(message: types.Message):\n    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)\n\n    keyboard.add(types.KeyboardButton(\n        text=\"Joylashuvni so'rash\", request_location=True\n    ))\n    keyboard.add(types.KeyboardButton(\n        text=\"Kontaktni so'rash\", request_contact=True\n    ))\n    keyboard.add(types.KeyboardButton(\n        text=\"Viktorina yaratish\",\n        request_poll=types.KeyboardButtonPollType(type=types.PollType.QUIZ)\n    ))\n\n    await message.answer(\"Amalni tanlang:\", reply_markup=keyboard)\n</code></pre></p>"},{"location":"buttons/#inline-buttons","title":"Inlayn tugmalar","text":""},{"location":"buttons/#url-callback-buttons","title":"URL-tugmalar va callbacklar","text":"<p>Oddiy tugmalardan farqli o'laroq, inlayn tugmalar ekranning pastki qismiga emas, balki ular yuborilgan xabarga birikib keladi. Ushbu bobda biz bunday tugmalarning ikki turini ko'rib chiqamiz: URL va Callback. Yana biri - Switch - uni inlayn rejim haqidagi bobda muhokama qilamiz.</p> <p>Kitobda \"Login\" va \"Pay\" tugmalari umuman ko'rib chiqilmaydi. Agar kimdir hech bo'lmaganda avtorizatsiya yoki to'lov uchun ishlab turgan kod bilan yordam berishni xohlasa, iltimos, GitHubda Pull Request yarating. Rahmat!</p> <p>Eng oddiy inlayn tugmalar URL turiga mansubdir, ya'ni \u00abhavola\u00bb. Va shuni unutmangki, faqat HTTP(S) va tg:// protokollari qo'llab-quvvatlanadi.</p> <pre><code>@dp.message_handler(commands=\"inline_url\")\nasync def cmd_inline_url(message: types.Message):\n    buttons = [\n        types.InlineKeyboardButton(text=\"GitHub\", url=\"https://github.com\"),\n        types.InlineKeyboardButton(\"Telegram kanali\", \"tg://resolve?domain=telegram\")\n    ]\n    keyboard = types.InlineKeyboardMarkup(row_width=1)\n    keyboard.add(*buttons)\n\n    await message.answer(\"Havolalar\", reply_markup=keyboard)\n</code></pre> <p>Va agar siz ikkala tugmani ketma-ket joylashtirishni istasangiz, <code>row_width=1</code>ni olib tashlang (standart qiymat 3 ishlatilinadi).</p> <p>URL tugmalari, aslida, muhokama qilish uchun boshqa hech narsa yo'q, shuning uchun bugungi dasturning diqqatga sazovor tomoniga o'tamiz - callback tugmalari. Bu juda kuchli narsa, uni deyarli hamma joyda ko'rishingiz mumkin. Xabarlar uchun reaksiya tugmalari (yoqtirishlar), @BotFather uchun menyular va boshqalar. Xulosa: callback tugmalari maxsus qiymatga (data) ega bo'lib, sizning ilovangiz nima bosilganligini va nima qilish kerakligini shundan bilib oladi. Va to'g'ri datani tanlash juda muhim! Shuni ham ta'kidlash joizki, oddiy tugmalardan farqli o'laroq, callback tugmasini bosish sizga pitsa buyurtma qilishdan tortib, serverni qayta ishga tushirishgacha bo'lgan deyarli hamma narsani qilish imkonini beradi.</p> <p><code>/random</code> buyrug'i yordamida callback tugmasi bilan xabar yuboradigan handler yozamiz: <pre><code>@dp.message_handler(commands=\"random\")\nasync def cmd_random(message: types.Message):\n    keyboard = types.InlineKeyboardMarkup()\n    keyboard.add(types.InlineKeyboardButton(\n        text=\"\u041d\u0430\u0436\u043c\u0438 \u043c\u0435\u043d\u044f\", \n        callback_data=\"random_value\"\n    ))\n\n    await message.answer(\n        text=\"\u041d\u0430\u0436\u043c\u0438\u0442\u0435 \u043d\u0430 \u043a\u043d\u043e\u043f\u043a\u0443, \u0447\u0442\u043e\u0431\u044b \u0431\u043e\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u043b \u0447\u0438\u0441\u043b\u043e \u043e\u0442 1 \u0434\u043e 10\", \n        reply_markup=keyboard\n    )\n</code></pre></p> <p>Lekin bosilgan tugmani qanday aniqlash kerak? Agar ilgari yuborilgan xabarlarni qayta ishlash uchun <code>message_handler</code>dan foydalangan bo\u2018lsak, endi callbacklarni qayta ishlash uchun <code>callback_query_handler</code>dan foydalanamiz. Biz tugmaning \"qiymati\"ga e'tibor qaratamiz, ya'ni. uning datasi:</p> <pre><code>@dp.callback_query_handler(text=\"random_value\")\nasync def send_random_value(call: types.CallbackQuery):\n    await call.message.answer(str(randint(1, 10)))\n</code></pre> <p>Muhim</p> <p>CallbackQuery obyektidagi ma'lumot <code>data</code> deb nomlangan maydonda saqlanishi va u <code>data</code> deb nomlanishiga qaramay, aiogramda uni <code>text</code> filtri ostida nomlashgan. Yuqoridagi kodni filtriga e'tibor bering!</p> <p></p> <p>Bu soatcha nima? Ma\u2019lum bo\u2018lishicha, Telegram serveri bizdan callbackni yetkazib berilganligini tasdiqlashimizni kutmoqda, aks holda u 30 soniya davomida aylanib turaveradi.  </p> <p>Soatchani yashirish uchun siz callbackda <code>answer()</code> metodini ishlatishingiz kerak (ya'ni <code>answer_callback_query()</code>).  </p> <p>Umuman olganda, siz <code>answer()</code> metodiga qo'shimcha hech narsa o'tkazishingiz shart emas, lekin siz maxsus oynachani chaqirishingiz mumkin.  </p> <p>(ekranning tepasida yoki barcha oynalar ustidan alohida OK tugmasi mavjud oyna):</p> <pre><code>@dp.callback_query_handler(text=\"random_value\")\nasync def send_random_value(call: types.CallbackQuery):\n    await call.message.answer(str(randint(1, 10)))\n    await call.answer(text=\"\u0421\u043f\u0430\u0441\u0438\u0431\u043e, \u0447\u0442\u043e \u0432\u043e\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043b\u0438\u0441\u044c \u0431\u043e\u0442\u043e\u043c!\", show_alert=True)\n    # yoki shunchaki await call.answer()\n</code></pre> <p></p> <p>Eslatma</p> <p><code>send_random_value</code> funksiyasida biz <code>answer()</code> metodini <code>message</code>da emas, balki <code>call.message</code>da chaqirdik. Buning sababi, callback-handlerlari Message bilan emas, balki boshqa maydon(field)larga ega bo'lgan CallbackQuery bilan ishlaydi va <code>message</code> uning bir qism(field)i xolos. Shuni ham yodda tutingki, <code>call.message</code> - tugma biriktirilgan xabardir (bu xabar egasi botning o'zi).</p> <p>Qachon <code>answer()</code>ni ishlatish kerak?</p> <p>Umuman olganda, asosiysi Telegramga callbackni qabul qildik ma'nosida xabar berishni unutmaslik kerak, men <code>answer()</code>ni doim eng oxirida qo\u2018yishni tavsiya qilaman, buning sababi: agar callbackni handle qilish (qayta ishlash) jarayonida xatolik yuz bersa, va bot exceptionga tushib qolsa, foydalanuvchi yuqolmayotgan soatchani ko'radi va nimadir noto'g'ri ekanligini tushunadi. Darhol javob qaytarilsa, soatcha yuqoladi va foydalanuvchi uning so'rovi muvaffaqiyatli bo'ldimi yoki yo'qmi, qorong'ulikda qoladi.</p> <p>Keling, qiyinroq misolga o'tamiz. Foydalanuvchiga 0 raqami bilan message yuborib, unga uchta inlayn tugma: \"+1\", \"-1\" va \"Tasdiqlash\" keyboard biriktiramiz. Birinchi ikkitasi bilan u raqam qiymatini mos ravishda +1 ga va -1 ga oshirib messageni edit(tahrir) qiladi, oxirgisi esa o'zgarishlarni tasdiqlab, inlayn keyboardni o'chiradi.</p> <pre><code># Bu yerda foydalanuvchi ma'lumotlari saqlanadi.\n# Qiymatni lug'at(dict) xotirasida saqlaymiz,\n# u qayta ishga tushirilganda tozalanadi\nuser_data = {}\n\ndef get_keyboard():\n    # Keyboard yaratish.\n    buttons = [\n        types.InlineKeyboardButton(text=\"-1\", callback_data=\"num_decr\"),\n        types.InlineKeyboardButton(text=\"+1\", callback_data=\"num_incr\"),\n        types.InlineKeyboardButton(\"\u041f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044c\", callback_data=\"num_finish\")\n    ]\n\n    keyboard = types.InlineKeyboardMarkup(row_width=2)\n    keyboard.add(*buttons)\n\n    return keyboard\n\n\nasync def update_num_text(message: types.Message, new_value: int):\n    # Xabarni yangi qiymat bilan o'zgartiramiz\n    await message.edit_text(\n        text=f\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e: {new_value}\", \n        reply_markup=get_keyboard()\n    )\n\n# /numbers buyrug'i uchun handler\n@dp.message_handler(commands=\"numbers\")\nasync def cmd_numbers(message: types.Message):\n    user_data[message.from_user.id] = 0\n    await message.answer(\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e: 0\", reply_markup=get_keyboard())\n\n\n@dp.callback_query_handler(Text(startswith=\"num_\"))\nasync def callbacks_num(call: types.CallbackQuery):\n    # Foydalanuvchining joriy qiymatni olamiz\n    user_value = user_data.get(call.from_user.id, 0)\n\n    # stringni bo'laklab qaysi amal bajarish kerakligini ko'satamiz,\n    # ya'ni, `num_incr` -&gt; `['num', 'incr']` -&gt; `incr`\n    action = call.data.split(\"_\")[1]\n\n    if action == \"incr\":\n        user_data[call.from_user.id] = user_value + 1\n        await update_num_text(call.message, user_value + 1)\n\n    elif action == \"decr\":\n        user_data[call.from_user.id] = user_value - 1\n        await update_num_text(call.message, user_value - 1)\n\n    elif action == \"finish\":\n        # Biz xabarni o'zgartirmasdan, \n        # await call.message.delete_reply_markup()\n        # chaqirib keyboardni o'chirib tashlashimiz mumkin edi. \n        # Ammo xabarni edit qilib va yangi keyboard yubormasak ham, \n        # default `reply_markup=None` bo'lganligi uchun keyboard o'chiriladi.\n        await call.message.edit_text(f\"\u0418\u0442\u043e\u0433\u043e: {user_value}\")\n\n    # Callbackni qabul qildik u bilan ishladik, tg xavotirlanma.\n    await call.answer()\n</code></pre> <p>Va hammasi ishlayotganga o'xshaydi: </p> <p></p> <p>Ammo keling qaysidir aqlli foydalanuvchi <code>/numbers</code> buyrug'ini chaqirdi (qiymat 0 ga teng) va qiymatni \"+1\" ga oshirdi (qiymat 1), va yana bir marta <code>/numbers</code>ni chaqirdi (endi qiymat yana 0 ga tenglandi). Endi bu \"\u043f\u043e\u043b\u0443\u0444\u0430\u0431\u0440\u0438\u043a\u0430\u0442\" birinchi yuborgan buyrug'iga kelgan xabardagi \"+1\" tugmasiga yana bosdi deb tasavvur qilaylik.</p> <p>Xo'sh nima bo'ladi? Bot halollik bilan matndagi qiymatni \"1\"ga edit qilishga harakat qiladi, lekin bu matn allaqachon 1 qiymatiga ega, Bot API eski matn, yangi matn bilan bir xil ekanligi to'g'risidagi xatoni qaytaradi va bot exceptionga uchraydi:  </p> <p><code>aiogram.utils.exceptions.MessageNotModified: Message is not modified: specified new message content and reply markup are exactly the same as a current content and reply markup of the message</code></p> <p></p> <p>Avvaliga xabarlarni edit qilishga urinayotganda, bu xatoga tez-tez duch kelishingiz mumkin. Ammo, aslida, muammo juda oddiy hal qilinadi: biz shunchaki <code>MessageNotModified</code> exceptionini e'tiborsiz qoldirishimiz kerak. Birinchi bobdan siz <code>errors_handler</code> kabi ajoyib narsa haqida allaqachon bilasiz, lekin bu safar biz bunga biroz boshqacha yondashamiz va <code>update_num_text()</code> funksiyasini quyidagicha qayta yozamiz:</p> <pre><code># from aiogram.utils.exceptions import MessageNotModified\n# from contextlib import suppress\n\nasync def update_num_text(message: types.Message, new_value: int):\n    with suppress(MessageNotModified):\n        await message.edit_text(\n            text=f\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e: {new_value}\",\n            reply_markup=get_keyboard()\n        )\n</code></pre> <p>Agar siz hozir yuqoridagi misoldagi aqlli foydalanuvchini harakatlarini takrorlashga harakat qilsangiz, bot ushbu kod blokdagi ko'rsatilgan Excepionni ignore qiladi (e'tiborsiz qoldiradi).</p>"},{"location":"buttons/#callback-factory","title":"Callbacklar fabrikasi","text":"<p>Aiogramda callback-factory deb ataladigan shunday narsa bor. Siz <code>CallbackData</code> obyektini yaratasiz, unga prefiks va ixtiyoriy miqdordagi argumentlarni kiritasiz, keyinchalik ularda ma'lumotlar saqlash uchun.</p> <p>Masalan, quyidagi obyektni ko'rib chiqing: <pre><code># from aiogram.utils.callback_data import CallbackData\n\ncb = CallbackData(\"post\", \"id\", \"action\")\n\n# post - bu prefiks filter ajratib olishi uchun (unikallashirish uchun)\n# id - bu o'zimiz yozgan yangi argument bu yerda biz idlarni kiritishimiz mumkin\n# action - ham argument bu yerda qanaqadir harakat nomini kiritamiz\n</code></pre> Tugma yaratishda siz uning parametrlarini quyidagicha belgilashingiz kerak: <pre><code>button =  types.InlineKeyboardButton(\n    text=\"Layk bosish\", \n    callback_data=cb.new(id=5, action=\"like\")\n)\n\n# bu yerda callback_data = 'post:5:like'\n</code></pre></p> <p>Endi <code>post</code> prefiksi uchun handler quyidagicha bo'ladi: <pre><code>@dp.callback_query_handler(cb.filter())\nasync def callbacks(call: types.CallbackQuery, callback_data: dict):\n    post_id = callback_data[\"id\"]\n    action = callback_data[\"action\"]\n    print(post_id, action) # 5 like\n</code></pre></p> <p>Raqamlar bilan oldingi misolda biz <code>callback_data</code>ni qiymatini ajratib olish oson qilib tanlagan edik, hamda vazifamiz bor-yog'i 3ta ishdan iborat ekanligini inobatga olib <code>callback_query_handler</code>ni bitta funksiya ichida \"\u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c\" qildik. Ammo biz vazifani \"+1\" va \"-1\" bosilganda alohida handler yoki bo'lmasam \"Tasdiqlash\" tugmasini bosilganda alohida handlerga mantiqiy bo'lib berishimiz mumkin.</p> <p>Buning uchun siz fabrika filtrida yasagan obyektingiz argumentlarining biriga tugmaga berilgan qiymatlarni mos ravishda ko'rsatishingiz kerak.  </p> <p>Keling, misolimizni qayta yozamiz:</p> <pre><code># fabnum - prefiks, action - biz qiymat kiritadigan argument nomi\ncallback_numbers = CallbackData(\"fabnum\", \"action\")\n\n\ndef get_keyboard_fab():\n    buttons = [\n        types.InlineKeyboardButton(\n            text=\"-1\", \n            callback_data=callback_numbers.new(action=\"decr\")\n        ),\n        types.InlineKeyboardButton(\n            text=\"+1\", \n            callback_data=callback_numbers.new(action=\"incr\")\n        ),\n        types.InlineKeyboardButton(\n            text=\"\u041f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044c\", \n            callback_data=callback_numbers.new(action=\"finish\")\n        )\n    ]\n\n    keyboard = types.InlineKeyboardMarkup(row_width=2)\n    keyboard.add(*buttons)\n\n    return keyboard\n\n\nasync def update_num_text_fab(message: types.Message, new_value: int):\n    with suppress(MessageNotModified):\n        await message.edit_text(\n            text=f\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e: {new_value}\", \n            reply_markup=get_keyboard_fab()\n        )\n\n\n@dp.message_handler(commands=\"numbers_fab\")\nasync def cmd_numbers(message: types.Message):\n    user_data[message.from_user.id] = 0\n    await message.answer(\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e: 0\", reply_markup=get_keyboard_fab())\n\n\n@dp.callback_query_handler(callback_numbers.filter(action=[\"incr\", \"decr\"]))\nasync def callbacks_num_change_fab(call: types.CallbackQuery, callback_data: dict):\n    user_value = user_data.get(call.from_user.id, 0)\n    action = callback_data[\"action\"]\n\n    if action == \"incr\":\n        user_data[call.from_user.id] = user_value + 1\n        await update_num_text_fab(call.message, user_value + 1)\n\n    elif action == \"decr\":\n        user_data[call.from_user.id] = user_value - 1\n        await update_num_text_fab(call.message, user_value - 1)\n\n    await call.answer()\n\n\n@dp.callback_query_handler(callback_numbers.filter(action=[\"finish\"]))\nasync def callbacks_num_finish_fab(call: types.CallbackQuery):\n    user_value = user_data.get(call.from_user.id, 0)\n    await call.message.edit_text(f\"\u0418\u0442\u043e\u0433\u043e: {user_value}\")\n    await call.answer()\n</code></pre> <p>Shunday qilib tugmalar haqidagi bob tugadi, keyingi boblarda ularning boshqa turlari haqida gaplashamiz.</p>"},{"location":"fsm/","title":"FSM (Steytlar)","text":""},{"location":"fsm/#theory","title":"Teoriya","text":"<p>Ushbu bobda biz botlarning, eng muhim xususiyati dialog tizimi haqida gaplashamiz. Afsuski, botdagi barcha amallarni bitta xabar yoki buyruqda bajarish mumkin emas. Aytaylik, tanishuv boti bor, u yerda ro'yxatdan o'tayotganda ismingizni, yoshingizni ko'rsatishingiz va rasmingizni yuborishingiz kerak. Siz, albatta, foydalanuvchidan rasm captionida hamma ma'lumotlarni yozib yuborishini so'rashingiz mumkin, ammo bu foydalanuvchi uchun ham sizning handleringiz uchun ham noqulay. Endi ma'lumotlarni bosqichma-bosqich kiritishni tasavvur qiling, bunda boshida bot ma'lum bir foydalanuvchidan ma'lum ma'lumotni kutish rejimini \u00abyoqadi\u00bb, so'ngra har bir bosqichda kiritilgan ma'lumotlarni tekshiradi va <code>/cancel</code> buyrug'i berilsa u keyingi qadamni kutishni to'xtatadi va asosiy rejimga qaytadi. Quyidagi sxemani ko'rib chiqing:</p> <p></p> <p>Yashil rang qadamlarni xatosiz o'tish jarayonini ko'rsatadi, ko'k joriy holatni saqlash va qayta kiritishni kutishni anglatadi (masalan, agar foydalanuvchi 250 yoshda ekanligini ko'rsatgan bo'lsa, siz yana yoshni so'rashingiz kerak), va qizil butun jarayondan chiqishni ko'rsatadi (masalan, <code>/cancel</code> buyrug'i dialogni to'xtatishi).</p> <p>Yuqoridagi diagrammadagi jarayon FSM \u2014 Finite State Machine deb ataladi. Bu haqda ko'proq ma'lumotni bu yerda o'qishingiz mumkin.</p>"},{"location":"fsm/#practice","title":"Amaliyot","text":"<p>Aiogramda FSM mexanizmi pyTelegramBotAPIga qaraganda ancha yaxshi ishlab chiqilgan. Freymvork ma'lum bir steytlar orasida olingan ma'lumotlarni saqlash uchun turli xil backendlarga ega va steytlarga qo'shimcha ravishda siz o'zingizni ma'lumotlaringizni keyinchalik biror joyda foydalanish uchun saqlashingiz mumkin. Mavjud FSM xotira(storage)lar ro'yxatini aiogram reposida topish mumkin va bu bobda biz barcha ma'lumotlarni RAMda saqlaydigan eng oddiy MemoryStorage backendidan foydalanamiz. Bu bizning ko'rsatadigan misollarimiz uchun mos, lekin uni real loyihalarda ishlatish tavsiya etilmaydi, chunki MemoryStorage barcha ma'lumotlarni diskka o'tkazmasdan operativ xotirada saqlaydi. Shuni ham ta'kidlash joizki, FSM nafaqat xabarlar bilan ishlovchilar (<code>message_handler</code>, <code>edited_message_handler</code>), balki callbacklar va inline rejimi bilan ham qo'llanilishi mumkin.</p> <p>Misol tariqasida biz kafeda oziq-ovqat va ichimliklar buyurtma qilish uchun steytlar yozamiz va shu bilan birga turli xil handlerlarni alohida fayllarda saqlashni o'rganamiz (Templating).</p> <p>Muhim</p> <p>Sahifada hamma bot kodlari ham ko'rib chiqilmaydi, o'qish oson bo'lishi uchun ba'zi importlar va handlerlar o'tkazib yuborilgan. Kodlarni GitHubda topish mumkin.</p> <p>Minnatdorchilik</p> <p>Tishka17ning tgbot_templatedan fayllar va kataloglar tuzilishi template(shablon) sifatida olindi. Ushbu bobda uning soddalashtirilgan versiyasi ko'rib chiqiladi, so'ngra bot murakkablashgani sayin fayl strukturasi kengayadi. Umuman olganda, Rahmat!</p>"},{"location":"fsm/#structure","title":"Fayl va katalog tuzilishi","text":"<p>Botimizni ishga tushuruvchi fayl <code>bot.py</code> fayli bo'ladi, uning yonida <code>bot.ini</code> konfiguratsiya(sozlama)lar fayli bilan \u00abconfig\u00bb papkasi joylashgan. Oldingi boblarda faqat bitta o'zgaruvchi environment variables orqali kiritilgan edi, lekin juda ko'p sozlamalar mavjud bo'lganida, alohida sozlamar faylidan foydalanish va uni standart Python Configparser bilan o'qish yaxshi. <code>app</code> papkasi ichida sozlamalar faylini o'qish uchun mas'ul bo'lgan <code>config.py</code> fayli, shuningdek, mantiqiy ravishda steytlarimizning turli qadamlari uchun handlerlar bilan <code>handlers</code> papkasi ham joylashgan.</p> <p>Sxematik ravishda, yuqorida aytilganlarning barchasi quyidagicha ko'rinadi:</p> <pre><code>\u251c\u2500\u2500 app/\n\u2502 \u251c\u2500\u2500 config.py\n\u2502 \u251c\u2500\u2500 handlers/\n\u2502 \u2502 \u251c\u2500\u2500 common.py\n\u2502 \u2502 \u251c\u2500\u2500 drinks.py\n\u2502 \u2502 \u251c\u2500\u2500 food.py\n\u2502 \u2502 \u2514\u2500\u2500 __init__.py\n\u2502 \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 config/\n\u2502 \u2514\u2500\u2500 bot.ini\n\u251c\u2500\u2500 bot.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre> <p>Modullar, fayllar va papkalar haqida</p> <p>Pythondagi modullar <code>*.py</code> fayllarini boshqa papkalarda chaqirish o'zaro konflikt keltirmasdan import qilish, papkalardagi <code>__init__.py</code> fayllari haqida bilsangiz kerak endi. Batafsil ushbu devpractice.ru saytdan o'qib, o'rganishingiz mumkin.</p>"},{"location":"fsm/#define-states","title":"Qadamlarni yaratish","text":"<p>Keling oziq-ovqatlar \u00abbuyurtma berish\u00bb bosqichini ko'rib chiqamiz. Boshlanishiga, <code>app/handlers/food.py</code> faylida biz kerakli obyektlarni import qilamiz va taomlar hamda ularning portsiya hajmlarini alohida listlarga yozib chiqamiz (realda bu ma'lumotlarni har qanday DBdan dinamik ravishda yuklashingiz mumkin):</p> <pre><code>from aiogram import Dispatcher, types\nfrom aiogram.dispatcher import FSMContext\nfrom aiogram.dispatcher.filters.state import State, StatesGroup\n\navailable_food_names = [\"sushi\", \"spagetti\", \"xachapuri\"]\navailable_food_sizes = [\"kichik\", \"o'rtacha\", \"katta\"]\n</code></pre> <p>Keling, ma'lum bir jarayonning barcha mumkin bo'lgan \u00abholatlarini\u00bb yozib chiqaylik (oziq-ovqat tanlash): foydalanuvchi <code>/food</code> buyrug'ini chaqiradi, bot sizdan taom tanlashni so'ragan xabar bilan javob beradi va foydalanuvchidan *taom tanlanishini kutish* steytiga tushadi. Foydalanuvchi tanlovni amalga oshirishi bilanoq, bot kiritilgan ma'lumotlarning to'g'riligini tekshiradi va keyingi steytda *portsiya hajmi*ni tanlashini kutib turadi. Foydalanuvchi bu yerda ham to'g'ri ma'lumotlarni kiritganida, bot yakuniy natijani (buyurtmani) ko'rsatadi va jarayon yakunlanadi (finish). Keyinroq, <code>/cancel</code> buyrug'i bilan istalgan bosqichda steytdan chiqish (jarayonni bekor qilish)ni o'rganamiz.</p> <p>Endi, steytlarimizni yozamiz. Ularni foydalanuvchi borishi kerak bo'lgan tartibda aniq yozish tavsiya etiladi (ya'ni birinchi taom tanlash, so'ngra portsiyani tanlash), bu kodni tushunarliroq qiladi. Steytarni saqlash uchun siz <code>StatesGroup</code> classidan meros class(steyt guruhi) yaratib, uning ichida <code>State</code> klassi ekzemplyariga teng o'zgaruvchilar yaratishimiz kerak:</p> <pre><code>class OrderFood(StatesGroup):\n    waiting_for_food_name = State()\n    waiting_for_food_size = State()\n</code></pre> <p><code>/food</code> buyrug'iga javob beradigan birinchi qadam(steyt) uchun handlerini yozamiz (uni keyinroq ro'yxatdan o'tkazamiz):</p> <pre><code># E'tibor bering: ikkinchi argument mavjud\nasync def food_start(message: types.Message, state: FSMContext):\n    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)\n    for name in available_food_names:\n        keyboard.add(name)\n\n    await message.answer(\"Taom tanlang:\", reply_markup=keyboard)\n    await state.set_state(OrderFood.waiting_for_food_name.state)\n</code></pre> <p>Oxirgi qatorda biz botga <code>OrderFood</code> guruhidan <code>waiting_for_food_name</code> steytini o'rnatishini aytdik. Endi u <code>/food</code> buyru'gidan keyin taomlarimiz menyusi bilan foydalanuvchidan ma'lumot kutib turadi. </p> <p>Quyidagi funksiya esa foydalanuvchidan olingan matnni saqlab (agar u to'g'ri bo'lsa) keyingi bosqichga o'tkazadi:</p> <pre><code>async def food_chosen(message: types.Message, state: FSMContext):\n    if message.text.lower() not in available_food_names:\n        await message.answer(\"Iltimos, menyudan foydalaning.\")\n        return\n\n    await state.update_data(chosen_food=message.text.lower())\n\n    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)\n    for size in available_food_sizes:\n        keyboard.add(size)\n\n    await state.set_state(OrderFood.waiting_for_food_size.state)\n    await message.answer(\"Endi portsiyani tanlang:\", reply_markup=keyboard)\n</code></pre> <p>Keling, yuqoridagi kodning ba'zi qatorlarni alohida tahlil qilaylik. <code>food_chosen</code> funksiya (1-qator) <code>FSMContext</code> turidagi ikkinchi <code>state</code> argumentga ega. U orqali siz FSM-backendidan ma'lumotlarni olishingiz mumkin. 2-qator foydalanuvchidan kelgan matnni tekshiradi. Agar u o'zboshimchalik bilan matn kiritgan bo'lsa va tugmalardan foydalanmasa, xato haqida xabar berishimiz va funksiyani muddatidan oldin tugatishimiz kerak. Bunday holda, foydalanuvchining qadami o'zgarmay qoladi va bot yana taom tanlanishini kutadi. Biz 5-qatorda, foydalanuvchi taomni to'g'ri kiritganiga \u0443\u0436\u0435 aminmiz, shuning uchun biz qabul qilingan matnni FSM bazasiga xavfsiz saqlashimiz mumkin. <code>update_data()</code> funksiyasidan foydalanamiz va xabar matnini <code>chosen_food</code> kaliti ostida <code>message.text.lower()</code> qiymati bilan saqlaymiz. 11-qatorda biz foydalanuvchini keyingi bosqichga o'tkazishga tayyormiz va ichida kerakli steyt bilan <code>set_state(...)</code> metodini chaqiramiz.</p> <p>Porstiya hajmini olish (shunga o'xshash matn tekshiruvi bilan) va natijalarni foydalanuvchiga ko'rsatish uchun javobgar oxirgi funksiyani yozish qoldi:</p> <pre><code>async def food_size_chosen(message: types.Message, state: FSMContext):\n    if message.text.lower() not in available_food_sizes:\n        await message.answer(\"Iltimos, menyudan foydalaning.\")\n        return\n    user_data = await state.get_data()\n    await message.answer(\n        f\"Buyurtma: {user_data['chosen_food']} taomidan {message.text.lower()} ports.\\n\"\n        f\"Ichimlik buyurtma berish uchun: /drinks\", \n        reply_markup=types.ReplyKeyboardRemove()\n    )\n    await state.finish()\n</code></pre> <p>E'tiboringizni qarating: Birinchidan, biz FSMdan saqlangan ma'lumotlarni <code>state</code>ning <code>get_data()</code> metodi yordamida olishimiz mumkin. Ikkinchidan, bu ma'lumotlar <code>dict</code> ko'rinishida saqlangani uchun, olishda <code>user_data['chosen_food']</code>dan foydalanishimiz mumkin (<code>dict</code>da qaysidir kalit bo'lmasligi mumkinligini unutmang, bu <code>KeyError</code>ga olib keladi, yaxshisi <code>.get('chosen_food')</code> metodidan foydalaning). Uchinchidan, <code>finish()</code> metodini chaqirish nafaqat steytni to'xtatadi, balki saqlangan ma'lumotlarni ham o'chiradi. Agar siz faqat steytni to'xtatishingiz kerak bo'lsa, <code>await state.reset_state(with_data=False)</code>dan foydalaning.</p> <p>Va nihoyat, yuqoridagi funksiylarning handlerlarini ro'yxatdan o'tkazish uchun alohida bitta funksiya yozamiz, u argumentida dispetcherni qabul qiladi. <code>food_start()</code>ni ro'yxatdan o'tkazishda steyt parametriga \"*\" qiymatini qo'yganimiz istalgan qadam(steyt)dan chiqib ishlashini bildiradi. Qo'pol qilib aytganda, agar foydalanuvchi *portsiya hajmini tanlash* steytida bo'lsa-yu, lekin qaytadan boshlashga qaror qilsa va <code>/food</code>ga buyruq bersa, bot <code>food_start()</code>ni chaqiradi va butun jarayonni qaytadan boshlaydi.</p> <pre><code>def register_handlers_food(dp: Dispatcher):\n    dp.register_message_handler(food_start, commands=\"food\", state=\"*\")\n    dp.register_message_handler(food_chosen, state=OrderFood.waiting_for_food_name)\n    dp.register_message_handler(food_size_chosen, state=OrderFood.waiting_for_food_size)\n</code></pre> <p>Ichimlik tanlash bosqichlari ham xuddi shu tarzda amalga oshiriladi. Buni o'zingiz sinab ko'ring yoki ushbu bobning githubda manbalariga qarang.</p>"},{"location":"fsm/#common-commands","title":"Umumiy buyruqlar","text":"<p>Biz steytlarni qayta boshlash yoki to'xtatish haqida gapirayotgan ekanmiz, keling, <code>app/handlers/common.py</code> faylida <code>/start</code> buyrug'i va \u00abbekor qilish\u00bb amaliga javob beruvchi handlerlarni yozamiz. Birinchisi xush kelibsiz/qo'llanma matnini ko'rsatadi, ikkinchisi esa \"Harakat bekor qilindi\" deb yozadi. Ikkala funksiya ham steyt va ma'lumotlarni o'chirib yuboradi va agar mavjud bo'lsa, replykeyboardni olib tashlaydi:</p> <pre><code>async def cmd_start(message: types.Message, state: FSMContext):\n    await state.finish()\n    await message.answer(\n        \"Buyurtma qilmoqchi bo'lgan narsani tanlang:\\n\"\n        \"ichimliklar (/drinks) yoki taom (/food).\",\n        reply_markup=types.ReplyKeyboardRemove()\n    )\n\nasync def cmd_cancel(message: types.Message, state: FSMContext):\n    await state.finish()\n    await message.answer(\n        text=\"Harakat bekor qilindi\", \n        reply_markup=types.ReplyKeyboardRemove()\n    )\n</code></pre> <p>Ikkila handlerni ro'yxatdan o'tkazamiz:</p> <pre><code>def register_handlers_common(dp: Dispatcher):\n    dp.register_message_handler(cmd_start, commands=\"start\", state=\"*\")\n    dp.register_message_handler(cmd_cancel, commands=\"cancel\", state=\"*\")\n    dp.register_message_handler(cmd_cancel, Text(equals=\"bekor qilish\", ignore_case=True), state=\"*\")\n</code></pre> <p>Nega ikkita emas, uchta qator? Gap shundaki, bitta handlerni turli xil hodisalarda chaqirish mumkin. Bu yerda biz <code>/cancel</code> buyrug'ida ham, \"Bekor qilish\" xabarini (katta-kichik harflarda) yuborishda ham chaqiriladigan <code>cmd_cancel()</code> funksiyasini ro'yxatdan o'tkazdik. Aytgancha, agar siz dekoratorlardan foydalanmoqchi bo'lsangiz, u quyidagicha ko'rinadi:</p> <pre><code>@dp.message_handler(commands=\"cancel\", state=\"*\")\n@dp.message_handler(Text(equals=\"bekor qilish\", ignore_case=True), state=\"*\")\nasync def cmd_cancel(message: types.Message, state: FSMContext):\n    ...\n</code></pre>"},{"location":"fsm/#entrypoint","title":"Kirish nuqtasi","text":"<p>Keling, <code>bot.py</code> fayliga qaytaylik va ikkita funksiya yozaylik: <code>set_commands()</code> va <code>main()</code>. Birinchisida biz Telegramda <code>Menyu</code> yoki <code>[ / ]</code> tugmasini bosishda chiqadigan, buyruqlar ro'yxatini kiritamiz, ikkinchisida esa botni ishga tushirish uchun kerakli amallarni bajaramiz: handlerlarni ro'yxatga olish, konfiguratsiya faylini o'qish, <code>Bot</code> va <code>Dispetcher</code>ni yaratish, va nihoyat botni polling rejimida ishga tushirish:</p> <pre><code># Importlarni unutmang\n\nlogger = logging.getLogger(__name__)\n\n# Telegramda ko'rsatiladigan \n# buyruqlarni ro'yxatdan o'tkazish\nasync def set_commands(bot: Bot):\n    commands = [\n        BotCommand(command=\"/drinks\", description=\"Ichimlik buyurtma berish\"),\n        BotCommand(command=\"/food\", description=\"Taom buyurtma berish\"),\n        BotCommand(command=\"/cancel\", description=\"Joriy harakatni bekor qilish\")\n    ]\n    await bot.set_my_commands(commands)\n\n\nasync def main():\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s - %(levelname)s - %(name)s - %(message)s\",\n    )\n    logger.error(\"Starting bot\")\n\n    # bot.ini faylini o'qish\n    config = load_config(\"config/bot.ini\")\n\n    # Bot va dispetcher obyektlari\n    bot = Bot(token=config.tg_bot.token)\n    dp = Dispatcher(bot, storage=MemoryStorage())\n\n    # Handlerlarni ro'yxatdan o'tkazish\n    register_handlers_common(dp)\n    register_handlers_drinks(dp)\n    register_handlers_food(dp)\n\n    # Bot buyruqlarini sozlash\n    await set_commands(bot)\n\n    # Botni pollingda ishga tushurish\n    # await dp.skip_updates()  # eski updatelarni o'tkazib yuborish (ixtiyoriy)\n    await dp.start_polling()\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> <p>Endi, FSM bilan qurollangan holda, siz qo'rqmasdan dialog tizimli botlarni yozishingiz mumkin.</p>"},{"location":"inline_mode/","title":"Inlayn-mode","text":""},{"location":"inline_mode/#intro","title":"Kirish","text":"<p>Oldingi boblarda bot va foydalanuvchi o\u2018zaro muloqot qilgan bo\u2018lsa, Telegramda foydalanuvchiga o\u2018z nomidan ammo ma\u2019lumotlarni bot orqali olib yuborish imkonini beruvchi maxsus rejim mavjud. Bu inlayn rejimi (Inline mode) deb nomlanadi:</p> <p></p> <p>Yuqoridagi skrinshotda ko'rib turganingizdek, yakuniy xabar foydalanuvchi nomidan yuboriladi, biroq dastlabki ro'yxat @imdb boti tomonidan taqdim etilgan. Inline rejimining foydalanuvchilar uchun batafsil tavsifini rasmiy veb-saytda topish mumkin va ushbu bobda biz YouTube videolarni topish va havolalarni yuborishni osonlashtirish uchun o'zimizning oddiy inline botimizni yozamiz.</p>"},{"location":"inline_mode/#inline-query-format","title":"Inline so'rovlar va javoblar shakli","text":"<p>Qachonki foydalanuvchi xabar yozish maydoniga botning username bilan uni chaqirsa, bot InlineQuery turidagi updateni oladi, undan biz uchun <code>from_user</code> fieldi muhim bo'lib, User turi botni chaqirgan foydalanuvchi haqida ma'lumotni, shuningdek, <code>query</code> fieldi, ya'ni so'rov matnini o'z ichiga oladi. Afsuski, hozirda inline bot qaysi chatda chaqirilganligini aniqlashning imkoni yo'q, ehtimol bu foydalanuvchilarning maxfiyligini saqlash uchun qilingan, chunki inline rejimidan foydalanish uchun botni guruh yoki kanalga qo\u2018shish shart emas.</p> <p>So'rovga javob berish uchun answerInlineQuery metodini chaqirish kerak, bu yerda siz natijani ma'lum bir turdagi obyektlar massivini va qo'shimcha ravishda turli xil bayroqcha(True-False)larni belgilashingiz kerak, bu haqida keyinroq gaplashamiz. Natija obyektlarining yigirmatacha turi mavjud, ammo ularning ko'plari bir-birining o'zgarishidir. Masalan, InlineQueryResultPhoto rasmga havolani (URL) o'z ichiga oladi va InlineQueryResultCachedPhoto allaqachon Telegramga yuklangan rasmning <code>file_id</code>ni o'z ichiga oladi. Bundan tashqari, inline javobda bir xil turdagi obyektlardan foydalanish tavsiya etiladi, chunki foydalanuvchi ilovalari aralash kontentni to'g'ri ko'rsatmaydi (yoki umuman ko'rsatmaydi).</p> <p>Diqqat: inline rejimida siz Telegramga yangi media fayllarni yuklay olmaysiz, faqat telegram serverlaridagi mavjudlaridan foydalaning yoki Internetdan URL manzilini belgilang.</p> <p>Eng ko\u02bbp qo\u02bbllaniladigan natija obyekt turlaridan biri oddiy matn bo\u02bblgan InlineQueryResultArticle hisoblanadi. Keling, obyektning asosiy elementlarini batafsil ko'rib chiqaylik:</p> <p></p> <p>Yuqoridagi rasmdagi raqamlar quyidagilarni bildiradi: 1 - obyektning sarlavhasi; 2 - tavsif; 3 - oldindan ko'rish; 4 - agar foydalanuvchi (3)ni bosadigan bo'lsa, unga biriktirilgan havola. (1)dan tashqari hamma narsa ixtiyoriy. Agar siz (3)ni emas, balki uning o'ng tomonidagi narsani bossangiz, chatga nima yuboriladi? Buning uchun InputMessageContent turi mavjud bo'lib, u to'rtta kichik tip bilan ifodalanadi: Text, Location, Venue va Contact. Eng oddiy holatda, foydalanuvchi bunday havolalar ro'yxatini ko'radi, elementlardan birini bosadi va InputTextMessageContentda ko'rsatilgan matnni oladi.</p> <p>Qiyinmi? Lekin bu hammasi emas! InputMessageContent boshqa turdagi inline obyektlar bilan ham ishlatilishi mumkin, masalan, javob sifatida foydalanuvchiga stikerlar berish va bosilganda butun boshli stikerlar to'plamiga havola yuborish. Yoki inline rejimida sarlavhani bosganingizda filmning tavsifi. Tajriba qilib ko'ring!</p>"},{"location":"inline_mode/#practice","title":"Bot yozamiz","text":"<p>Nazariyadan amaliyotga. Botning mohiyatini tasvirlab beraylik: bot bilan muloqotda foydalanuvchi YouTube videosiga havolani qo\u2018shadi (yoki yangilaydi) va o\u2018zining tavsifini belgilaydi. Keyin istalgan boshqa suhbatda u botga inline rejimiga murojaat qiladi, ro\u2018yxatdan avval saqlangan videolardan birini tanlaydi va uni jo\u2018natadi. Albatta, har bir foydalanuvchi o'zining saqlangan havolalariga ega bo'lishi kerak.</p> <p>Texnologiya ishlatishda ogohlik</p> <p>Ushbu bobning asosiy maqsadi inline rejimi haqida gapirish bo'lganligi sababli, FSM ma'lumotlar bazasi va ma'lumotlarni saqlash kabi tegishli tafsilotlar ataylab soddalashtirilgan va matnda eslatib o'tilmaagan bo'lishi mumkin. Masalan, MemoryStorage FSM sifatida ishlatiladi va SQLite ma'lumotlar bazasi sifatida, bu bizga ushbu darsimiz uchun kifoya qiladi. Real proyektlarda esa, FSM doimiy xotirasidan (masalan, Redis) va yanada rivojlangan DBMS (masalan, PostgreSQL), shuningdek, alohida qidiruv tizimidan (ElasticSearch, Sonic...) foydalanish tavsiya etiladi.</p> <p>Bot inline rejimini yoqishni unutmang!</p> <p>Uni yoqish uchun @BotFather \u2192 <code>/mybots</code> \u2192 botingizni tanlang \u2192 Bot Settings \u2192 Inline Mode \u2192 Turn on. Agar kerak bo'lsa, siz qidiruv maydoni matnini \"Search...\"dan ko'zni quvontiradigan narsaga o'zgartirishingiz mumkin. Va ana endi eng yaxshisi Telegram ilovasini qayta ishga tushirish, aks holda mijoz qurilmasida mavjud telegram ilovasi botning inline rejimi yo\u2018qligini keshlashi mumkin.</p>"},{"location":"inline_mode/#storage","title":"Ma'lumotlarni saqlash","text":"<p>Yuqoridagi \u00abtalablar\u00bbga asoslanib, biz har bir saqlangan video uchta majburiy subyektlar tomonidan tavsiflanishi mumkin degan xulosaga keldik: Telegram foydalanuvchi identifikatori, YouTube video identifikatori (URLdan olingan) va foydalanuvchi tavsifi. Birinchi ikkita element asosiy kalitni tashkil qiladi, bu esa har bir \u00abTelegram_ID + YouTube_ID\u00bb juftligi uchun o'ziga xos unikal(unique)likni beradi. Ma'lumotlar bazasidagi jadval:</p> <pre><code>CREATE TABLE IF NOT EXISTS \"youtube\" (\n\"user_id\"   INTEGER NOT NULL,\n\"youtube_hash\"  TEXT NOT NULL,\n\"description\"   TEXT NOT NULL,\nPRIMARY KEY(\"user_id\", \"youtube_hash\")\n);\n</code></pre> <p>Avvalroq ma'lumotlar bazasiga uncha e'tiborimizni qaratmaslikka ko'proq inlayn rejimining xususiyatlariga to'xtalishni kelishib olgan edik, ammo quyidagi ikkita funksiyani ko'rib chiqish qo'shimcha zarar qilmaydi. Birinchisi, ma'lumotlar bazasiga tavsif bilan havola qo'shish. Bu erda \"UPSERT\" deb nomlangan bitta hiyla bor, ya'ni. Insert yoki Update. Gap shundaki, SQL so'rovini maxsus usulda shakllantirgandan so'ng, ma'lumotlarni kiritishda (Insert), unikallik buzilgan taqdirda, xatoga yo'l qo'ymasdan, balki shu qatorni bilvosita yangilash (Update)ni bildiradi. Kodning keyingi qismiga qarang. Unda biz ma'lumotlar bazasiga yangi qator qo'shishga harakat qilmoqdamiz, ammo agar ko'rsatilgan \u00abTelegram_ID + YouTube_ID\u00bb juftligi allaqachon mavjud bo'lsa, unda tavsif qo'shish o'rniga yangilanadi:</p> <pre><code>def insert_or_update(user_id: int, youtube_hash: str, description: str):\n    statement = \"INSERT INTO youtube (user_id, youtube_hash, description) \" \\\n                \"VALUES (:user_id, :youtube_hash, :description) \" \\\n                \"ON CONFLICT(user_id, youtube_hash) \" \\\n                \"DO UPDATE SET description = :description\"\n    cursor.execute(statement, {\n        \"user_id\": user_id,\n        \"youtube_hash\": youtube_hash,\n        \"description\": description\n    })\n    cursor.connection.commit()\n</code></pre> <p>Ikkinchi muhim funksiya - havolalar ro'yxatini olish. Foydalanuvchi natijani filtrlashni xohlashi mumkinligi sababli, ixtiyoriy ikkinchi <code>search_query</code> argumenti mavjud. Mavjudlarini topish uchun esa <code>LIKE</code> operatoridan foydalanamiz. Eslatib o'tamiz, realda bu yondashuv qidiruvning past samaradorligi va aniqligi tufayli mos sizga mos kelishi dargumon, ammo demonstratsiya qilish uchun bu yetarli bo'ladi:</p> <pre><code>def get_links(user_id: int, search_query: str = None):\n    statement = \"SELECT youtube_hash, description from youtube WHERE user_id = ?\"\n    if search_query:\n        statement += f\" AND description LIKE ?\"\n        result = cursor.execute(statement, (user_id, f\"%{search_query}%\"))\n    else:\n        result = cursor.execute(statement, (user_id,))\n    return result.fetchall()\n</code></pre>"},{"location":"inline_mode/#switch-buttons","title":"Switch-tugmalar","text":"<p>PMda havolalarni bot bilan ko'rish va o'chirish elementar tarzda amalga oshiriladi va qo'shish eng oddiy holat mashinasi yordamida tashkil etiladi (FSM mexanizmi haqida ko'proq ma'lumotni oldingi bobda topishingiz mumkin). Bizning oxirgi steytimiz quyidagicha ko'rinishda:</p> <pre><code>async def description_added(message: types.Message, state: FSMContext):\n    # FSM dan ma'lumot olish\n    user_data = await state.get_data()\n    # Ma'lumotlar bazasiga ma'lumotlarni kiritish\n    dbworker.insert_or_update(\n        user_id=message.from_user.id, \n        youtube_hash=user_data[\"yt_hash\"], \n        description=message.text\n    )\n    # switch-tugmalari bilan keyboard yaratish va xabar yuborish\n    switch_keyboard = types.InlineKeyboardMarkup()\n    switch_keyboard.add(\n        types.InlineKeyboardButton(\n            text=\"\u041f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c\", \n            switch_inline_query=\"\"\n        )\n    )\n    switch_keyboard.add(\n        types.InlineKeyboardButton(\n            text=\"\u041f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c \u0437\u0434\u0435\u0441\u044c\", \n            switch_inline_query_current_chat=\"\"\n        )\n    )\n    await message.answer(\n        \"\u0421\u0441\u044b\u043b\u043a\u0430 \u0438 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u044b \u0432 \u0438\u043d\u043b\u0430\u0439\u043d-\u0440\u0435\u0436\u0438\u043c \u0438 \"\n        \"\u0441\u0442\u0430\u043d\u0443\u0442 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b \u0432 \u0442\u0435\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u044b \u043c\u0438\u043d\u0443\u0442!\\n\"\n        \"\u041f\u043e\u043b\u043d\u044b\u0439 \u0441\u043f\u0438\u0441\u043e\u043a \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u0445 \u0441\u0441\u044b\u043b\u043e\u043a: /links\",\n        reply_markup=switch_keyboard\n    )\n    await state.finish()\n</code></pre> <p>Ilgari tugmalar bobida biz ikki turdagi inlayn tugmalarni ko'rdik: URL va Callback. Inline rejimi uchun uchinchi tur: Switch. Yuqoridagi kodda ikkita tugma e'lon qilingan, ulardan biri bo'sh <code>switch_inline_query</code> parametri, ikkinchisi bo'sh <code>switch_inline_query_current_chat</code> bilan. Birinchisi sizni chat tanlashni taklif qiladi, so'ngra inline rejimini faollashtirish uchun yozuv maydonida botning usernameni yozadi, ikkinchisi ham xuddi shunday, lekin joriy chatda (bizning holatda, bot bilan shaxsiy xabarda). Agar parametrlar bo'sh bo'lmasa va matn ko'rsatilgan bo'lsa, u botning username yoniga qo'shiladi, masalan: <code>switch_inline_query=\"text\"</code> -&gt; <code>@bot text</code>. @like boti xuddi shunday ishlaydi, bu sizga yangi yaratilgan postni darhol biror joyga yuborish imkonini beradi.</p>"},{"location":"inline_mode/#handle-incoming-query","title":"Inline so'rovni qayta ishlash","text":"<p>Keling, foydalanuvchining botga so'rovini inline rejimida handlega o'tamiz. Ba'zi hollarda, bo'sh so'rov uchun alohida handlerni yaratish (InlineQuery obyektining <code>query</code> maydonidagi matn uzunligi nolga teng bo'lganda) va qandaydir \"umumiy\" javob yoki botgga o'tish uchun taklifni ko'rsatish qulay. Lekin bizning holatlarimizda har qanday, hatto bo'sh so'rov ham DBga murojaat qilishimizni talab qiladi, shuning uchun ikkala holatni bitta handlerda birlashtiramiz. Birinchi variantni ko'rib chiqamiz: foydalanuvchida saqlangan havolalar yo'q yoki u hech narsa topilmaydigan so'rovni kiritdi. Keling, kodni ko'rib chiqaylik:</p> <pre><code>async def inline_handler(query: types.InlineQuery):\n    # Foydalanuvchi havolalarini olish (query bo'lmasa, None)\n    user_links = dbworker.get_links(query.from_user.id, query.query or None)\n    if len(user_links) == 0:\n        # Natijalar ustidagi sarlavha uchun matn tanlash\n        switch_text = \"\u0423 \u0432\u0430\u0441 \u043d\u0435\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u0445 \u0441\u0441\u044b\u043b\u043e\u043a. \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u00bb\u00bb\" \\\n            if len(query.query) == 0 \\\n            else \"\u041d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e \u0441\u0441\u044b\u043b\u043e\u043a \u043f\u043e \u0434\u0430\u043d\u043d\u043e\u043c\u0443 \u0437\u0430\u043f\u0440\u043e\u0441\u0443. \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u00bb\u00bb\"\n        return await query.answer(\n            [], cache_time=60, is_personal=True,\n            switch_pm_parameter=\"add\", \n            switch_pm_text=switch_text\n        )\n</code></pre> <p>Keling, ushbu kod qismini batafsil ko'rib chiqaylik. <code>InlineQueryResultArticle</code> obyekti ko'rib chiqilgan yuqoridagi rasmda yuqori qismida \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0441\u044b\u043b\u043a\u0443 \u00bb\u00bb\" qatorini ko'rishingiz mumkin, bu \"swtich-obyekti\", bizga botning shaxsiysiga <code>/start</code> buyrug'ini qo'shimcha parametr bilan o'tkazadi, bizning holatlarimizda bu <code>add</code>, ya'ni. bot <code>/start add</code> matni bilan xabar oladi va shunga mos ravishda javob bera oladi. Va kodning eng pastki qismida biz <code>answerInlineQuery</code> metodini chaqirib, qo'shimcha tarzda yana ikkita parametr: <code>cache_time</code> va <code>is_personal</code> beramiz. Birinchisi Telegram serverlarida natijalarni keshlash vaqti uchun javob beradi (sekundlarda) va standart qiymati 300 (5 daqiqa)ga teng. Bu shuni anglatadiki, agar foydalanuvchi belgilangan muddat ichida xuddi shunday so\u2018rov (hatto bo\u2018sh) bilan inline botga qo\u2018ng\u2018iroq qilsa (axax), Telegram uni botga yo\u2018naltirmaydi, balki keshdagi qiymat bilan darhol javob beradi. Ikkinchi parametr, <code>is_personal</code>, keshlashni har bir foydalanuvchi uchun unikal qiladi va natijalarni shaxsiylashtiradi (bu degani Aziz <code>salom</code> deb so'rov jo'natsa faqat Aziz uchun natijalar keshlanadi, Alida esa <code>salom</code> uchun alohida kesh, agar <code>is_personal=False</code> bo'lganida Aziz birinchi bo'lib so'rov yuborsa u umumiy hamma uchun <code>cache_time</code> vaqtiga qarab keshlanadi va boshqa barcha shu so'rovni yuborganlarda natija darhol chiqadi).</p> <p>Muallif bir marta @my_id_bot botida <code>is_personal</code> bayrog'chasiga <code>True</code> ko'rsatishni unutib qo'ygan, keshni 86400 soniya (1 kun)ga o'rnatgan va o'z IDsini o'rniga keshlangan boshqa foydalanuvchilar IDlar bilan chalkashlik sodir bo'lgan, foydalanuvchilar orasida ko'plab noroziliklarini keltirib chiqargan. Boshqalar qilgan xatoni siz takrorlamang!</p> <p>Endi ikkinchi holatni ko'rib chiqamiz: ba'zi havolalar foydalanuvchining so'roviga binoan topiladi. Keling, <code>InlineQueryResultArticle</code> turidagi natija obyektlar massivini tuzamiz:</p> <pre><code>user_links = dbworker.get_links(query.from_user.id, query.query or None)\n\narticles = [\n        types.InlineQueryResultArticle(\n            id=item[0],\n            title=item[1],\n            description=f\"https://youtu.be/{item[0]}\",\n            url=f\"https://youtu.be/{item[0]}\",\n            hide_url=False,\n            thumb_url=f\"https://img.youtube.com/vi/{item[0]}/1.jpg\",\n            input_message_content=types.InputTextMessageContent(\n                message_text=f\"&lt;b&gt;{quote_html(item[1])}&lt;/b&gt;\\nhttps://youtu.be/{item[0]}\",\n                parse_mode=\"HTML\"\n            )\n        ) for item in user_links\n    ]\n</code></pre> <p>Biz yuqoridagi ba'zi maydonlarni ko'rib chiqqan edik, qolganlarini ko'rib chiqaylik: <code>id</code> - natija obyektining unikal identifikatori uchun (bizning holatimizda bu YouTube video xeshini ishlatish juda qulay), <code>hide_url</code> - natijadagi havolaning (<code>url</code>) ko'rinishini belgilovchi param, <code>thumb_url</code> oldindan ko'rish tasviriga havola, qo'shimcha ravishda oldindan ko'rishning eni (<code>thumb_height</code>) va kengligi (<code>thumb_width</code>)ni belgilashingiz mumkin. <code>InputTextMessageContent</code> obyekti tayinlangan <code>input_message_content</code> argumenti yakuniy xabar uchun javobgardir. Matn formatini buzadigan yovuz belgilardan qochish uchun <code>quote_html()</code> ishlatilgan.</p> <p>Umuman olganda, inline handlerning to'liq kodi quyidagicha ko'rinadi: <pre><code>async def inline_handler(query: types.InlineQuery):\n    user_links = dbworker.get_links(query.from_user.id, query.query or None)\n\n    if len(user_links) == 0:\n        switch_text = \"\u0423 \u0432\u0430\u0441 \u043d\u0435\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\u043d\u044b\u0445 \u0441\u0441\u044b\u043b\u043e\u043a. \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u00bb\u00bb\" \\\n            if len(query.query) == 0 \\\n            else \"\u041d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e \u0441\u0441\u044b\u043b\u043e\u043a \u043f\u043e \u0434\u0430\u043d\u043d\u043e\u043c\u0443 \u0437\u0430\u043f\u0440\u043e\u0441\u0443. \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u00bb\u00bb\"\n        return await query.answer(\n            [], cache_time=60, is_personal=True,\n            switch_pm_parameter=\"add\", \n            switch_pm_text=switch_text\n        )\n\n    articles = [types.InlineQueryResultArticle(\n        id=item[0],\n        title=item[1],\n        description=f\"https://youtu.be/{item[0]}\",\n        url=f\"https://youtu.be/{item[0]}\",\n        hide_url=False,\n        thumb_url=f\"https://img.youtube.com/vi/{item[0]}/1.jpg\",\n        input_message_content=types.InputTextMessageContent(\n            message_text=f\"&lt;b&gt;{quote_html(item[1])}&lt;/b&gt;\\nhttps://youtu.be/{item[0]}\",\n            parse_mode=\"HTML\"\n        )\n    ) for item in user_links]\n    await query.answer(\n        articles, cache_time=60, is_personal=True,\n        switch_pm_text=\"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0441\u044b\u043b\u043a\u0443 \u00bb\u00bb\", \n        switch_pm_parameter=\"add\"\n    )\n</code></pre></p> <p>YouTube xeshi yordamida videoning turli xil ko'rinishlarini osongina olishingiz mumkinligini bilasizmi? Agar yo'q bo'lsa, StackOverflowdagi ushbu ajoyib postga o'ting.</p>"},{"location":"inline_mode/#switch-parameter","title":"Switch parameteri","text":"<p>Biz biroz yuqoriroqda ma'lum qilganimizdek, <code>switch_pm_parameter</code> start-parametr sifatida <code>/add</code> buyrug'ini bergan edik (Bot APIda bu Deep Linking deb ataladi). Uni handle qilish uchun biz <code>/start add</code> Deep-havolasini filtrlashimiz lozim, buning uchun biz ikkinchi quyidagi filtrni osha handlerimiz uchun ro'yxatdan o'tkazamiz:</p> <pre><code>dp.register_message_handler(cmd_add_link, commands=\"add\", state=\"*\")\ndp.register_message_handler(cmd_add_link, CommandStart(deep_link=\"add\"), state=\"*\")\n</code></pre> <p>Bot bilan hammasi shu, yuqori o'ng burchakdagi tugmani bosish orqali repoga o'tib manba kodlarini ko'rib chiqishingiz mumkin. Biroq inline rejimini tugatishdan avval, bir nechta qiziqarli xususiyatlarni ko'rib chiqishimiz kerak ...</p>"},{"location":"inline_mode/#extras","title":"Qo'shimcha materiallar","text":""},{"location":"inline_mode/#lazy-loading","title":"Natijalarni yuklash","text":"<p>Bot APIga ko'ra, bitta answerInlineQuery chaqiruvida maksimal 50 ta element yuborilishi mumkin. Ammo bizga ko'proq kerak bo'lsa-chi? Bunday holatda, <code>next_offset</code> parametri foydalanish kerak. U botning o'zi tomonidan belgilanadi va foydalanuvchi butun joriy paketni aylantirganda, xuddi shu qiymat keyingi so'rovda keladi. Misol uchun, 50 ta elementdan iborat paketlarni qaytaradigan, lekin maksimal qiymati 195 bo'lgan oddiy son generatorini yozamiz:</p> <pre><code>def get_fake_results(start_num: int, size: int = 50):\n    overall_items = 195\n    # Agar boshqa natijalar bo'lmasa, bo'sh ro'yxat yuboramiz\n    if start_num &gt;= overall_items:\n        return []\n    # To'liq bo'lmagan paketni yuborish (oxirgi)\n    elif start_num + size &gt;= overall_items:\n        return list(range(start_num, overall_items+1))\n    else:\n        return list(range(start_num, start_num+size))\n</code></pre> <p>Keling, inline-handlerimizni shunday yozaylikki, u joriy ro'yxatning oxiriga yaqinlashganda, u davom etishni so'raydi. Buning uchun avval <code>offset</code> maydonini tekshiramiz va agar bo'sh bo'lsa, uni 1 ga teng deymiz. Natijalarning soxta ro'yxatini yaratamiz. Agar natija aniq 50 ta obyekt bo'lsa, javobda joriy qiymatga + 50 ga teng <code>next_offset</code> belgilaymiz. Agar obyektlar kamroq bo'lsa, Telegram endi botga so'rov yubormasligi uchun uni bo'sh qatorga aylantiramiz.</p> <pre><code>async def inline_handler(query: types.InlineQuery):\n    # offsetni raqam sifatida hisoblaymiz\n    query_offset = int(query.offset) if query.offset else 1\n    results = [types.InlineQueryResultArticle(\n        id=str(item_num),\n        title=f\"\u041e\u0431\u044a\u0435\u043a\u0442 \u2116{item_num}\",\n        input_message_content=types.InputTextMessageContent(\n            message_text=f\"\u041e\u0431\u044a\u0435\u043a\u0442 \u2116{item_num}\"\n        )\n    ) for item_num in get_fake_results(query_offset)]\n    if len(results) &lt; 50:\n        # Boshqa natijalar yo\u2018q, next_offset bo\u2018sh qolishi kerak\n        await query.answer(results, is_personal=True, next_offset=\"\")\n    else:\n        # Keyingi to'plamni intiqlik bilan kutamiz :)\n        await query.answer(results, is_personal=True, next_offset=str(query_offset+50))\n</code></pre>"},{"location":"inline_mode/#inline-feedback","title":"Statistika to'plash","text":"<p>Kam odam biladi, lekin Telegram sizga inline rejimida botdan foydalanish bo'yicha oddiy statistik ma'lumotlarni to'plash imkonini beradi. Avval @BotFather uchun tegishli sozlamani yoqishingiz kerak: <code>/mybots</code> - (botni tanlang) - Bot Settings - Inline Feedback:</p> <p></p> <p>Tugmalardagi foizlar foydalanuvchi inline rejimida obyektni tanlaganda ChosenInlineResult hodisasini olish ehtimolini ko'rsatadi. Masalan, agar qiymat 10%ga o'rnatilgan bo'lsa, har bir obyektni tanlashda botda <code>ChosenInlineResult</code> hodisasini olish uchun o'n foiz imkoniyat mavjud. Telegram botga yuklanish ikki baravar ko\u2018paygani uchun qiymatni 100% qilib belgilashni tavsiya etmaydi. Bunday hodisalar uchun handlerga misol:</p> <pre><code>@dp.chosen_inline_handler()\nasync def chosen_handler(chosen_result: types.ChosenInlineResult):\n    logging.info(\n        f\"Chosen query: {chosen_result.query}\"\n        f\"from user: {chosen_result.from_user.id}\"\n    )\n</code></pre>"},{"location":"messages/","title":"Xabarlar bilan ishlash","text":"<p>Ushbu bobda biz xabarlarga har xil formatlash turlarini qo'llash va media fayllar bilan ishlashni o'rganamiz.</p>"},{"location":"messages/#text","title":"Matn","text":"<p>Xabarlarda matnlar bilan ishlash, bu, deyarli barcha botlar uchun eng muhimlaridan biridir. Matn deyarli hamma narsani ifodalashi mumkin va shu bilan birga ma'lumotni chiroyli ko'rinishi foydalanuvchida ham o'zgacha taasurot qoldiradi. Dasturchi matnni formatlashning uchta usuliga ega: HTML, Markdown va MarkdownV2. HTML va MarkdownV2 ularning eng ilg'orlari hisoblanadi, \"klassik\" Markdown eski va kamroq funksiyalari bo'lgani uchun kamroq foydalanamiz.</p> <p><code>parse_mode</code> argumenti xabarlarni yuborishda formatlashni tanlash uchun javobgar parametr, masalan:</p> <pre><code>from aiogram import types\n\n# funksiyaning biron bir joyida...\nawait message.answer(\"Hello, &lt;b&gt;world&lt;/b&gt;!\", parse_mode=types.ParseMode.HTML)\n# Enum* o'rniga parse_mode'ga oddiy satr(string) sifatida kiritish ham mumkin:\nawait message.answer(\"Hello, *world*\\!\", parse_mode=\"MarkdownV2\")\n</code></pre> <p>*Enum nima?</p> <p>Enum[erations] - bu unikal qiymatlarga ega konstanta(o'zgarmas)lar to'plami deyish mumkin. Ular global o'zgaruvchilarga o'xshaydi, lekin ular yanada foydali: repr(), guruhlash, turlardagi xavfsizlik va boshqa bir qancha xususiyatlarga ega.</p> <p></p> <p>Agar ma'lum bir formatlash usuli botning hamma joyida ishlatilsa, har safar <code>parse_mode</code> argumentini metodlarda belgilash ancha qimmatga tushadi. Yaxshiyamki, aiogramda siz kerakli formatlashni to'g'ridan-to'g'ri Bot obyektiga o'tkazishingiz mumkin va agar biron bir holatda siz ushbu formatlashni bekor qilishingiz kerak bo'lsa, shunchaki <code>parse_mode=\"\"</code> (bo'sh qator) qoldirasiz:</p> <pre><code># endi hamma matn bilan ishlovchi metodlarda HTML qo'llaniladi\nbot = Bot(token=\"123:abcxyz\", parse_mode=types.ParseMode.HTML)\n\n# funksiyaning biron bir joyida...\nawait message.answer(\"\u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0441 &lt;u&gt;HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u043e\u0439&lt;/u&gt;\")\nawait message.answer(\"\u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0431\u0435\u0437 &lt;s&gt;\u043a\u0430\u043a\u043e\u0439-\u043b\u0438\u0431\u043e \u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438&lt;/s&gt;\", parse_mode=\"\")\n</code></pre> <p></p> <p>Xabarni formatlashning nafaqat tepada ko'rgan \"dasturiy\" usuli ya'ni html, markdown bilan qo'lda taglarni ochib-yopish, balki \"dinamik\" usuli ham mavjud. Buning uchun <code>aiogram.utils</code>dan <code>markdown</code> modulini import qilishingiz kerak, bu modul nomiga qaramay, HTMLni ham qo'llab-quvvatlaydi.  </p> <p>Qisqasi \"dinamik\" usul ham syurpriz emas, import qilingan <code>markdown</code>dan <code>text()</code> funksiyasini chaqirib, uni ichiga formatlanadigan matnimizni ham alohida mos ravishda funksiyalarni chaqirgan holda <code>text()</code> funksiyasini ichida ishlatishimizga to'g'ri keladi, hammasi matnga bog'liq ammo siz taglardan qo'rqsangiz, ochib qaytib yopish esdan chiqsa sizga ancha qo'l kelishi mumkin.  </p> <p>Formatlash ham funksiyalar bilan belgilanadi deganimiz ya'ni <code>hbold()</code> funksiya ichiga matningizni qo'yib chaqirasz, funksiya boshidagi \"h\" esa HTML degan ma'noni anglatadi, va ushbu funksiya unga berilgan matnni HTMLda qalin (<code>&lt;b&gt;matn&lt;/b&gt;</code>) qilishi kerakligini bildiradi.</p> <p>Bilaman hech narsaga tushunmadingiz, umuman olganda, quyidagi kod va skrinshotga qarang. Matn formatlashning ushbu usuli foydalanishga arziydimi-yoqmi sizga bog'liq:</p> <pre><code>import aiogram.utils.markdown as fmt\n\n# funksiyaning biron bir joyida...\nawait message.answer(\n        fmt.text(\n            fmt.text(fmt.hunderline(\"\u042f\u0431\u043b\u043e\u043a\u0438\"), \", \u0432\u0435\u0441 1 \u043a\u0433.\"),\n            fmt.text(\"\u0421\u0442\u0430\u0440\u0430\u044f \u0446\u0435\u043d\u0430:\", fmt.hstrikethrough(50), \"\u0440\u0443\u0431\u043b\u0435\u0439\"),\n            fmt.text(\"\u041d\u043e\u0432\u0430\u044f \u0446\u0435\u043d\u0430:\", fmt.hbold(25), \"\u0440\u0443\u0431\u043b\u0435\u0439\"),\n            sep=\"\\n\"\n        ), parse_mode=\"HTML\"\n    )\n</code></pre> <p>Oxiridagi <code>sep</code> argumenti matn qismlari orasidagi ajratuvchini belgilaydi.</p> <p></p> <p>Formatlab yuborishdan tashqari, Aiogram sizga foydalanuvchi yuborgan (umuman olganda kiruvchi) matnni oddiy matn (plain text), HTML va Markdown sifatida olish imkonini beradi. Quyidagi skrinshotda ko'rishingiz mumkin. Bu yuboruvchiga uning xabarini kichik o'zgarishlar bilan qaytarishni istasangiz, foydalanish uchun qulaydir:</p> <pre><code>@dp.message_handler()\nasync def any_text_message(message: types.Message):\n    await message.answer(message.text)\n    await message.answer(message.md_text)\n    await message.answer(message.html_text)\n    # Asl matnni to'ldiramiz:\n    await message.answer(\n        f\"&lt;u&gt;\u0412\u0430\u0448 \u0442\u0435\u043a\u0441\u0442&lt;/u&gt;:\\n\\n{message.html_text}\", parse_mode=\"HTML\"\n    )\n</code></pre> <p></p> <p>Hammasi yaxshi, lekin formatlashdan foydalanishda muammo bor: ayyor foydalanuvchilar (hakrlar) ismlarida yoki xabarlarida maxsus tag va belgilarni foydalanishi mumkin va bu botni xato ishlashiga yoki buzishiga olib keladi. Biroq, aiogramda bunday holatlardan <code>escape_md()</code> \u0438 <code>quote_html()</code> yordamchi funksiyalar bilan qochish mumkin (umuman olganda qochilmaydi, matn tozalanadi).  Yoki yuqorida ko'rsatilgan usuldan foydalanishingiz mumkin (h)bold, (h)italic va boshqalar:</p> <pre><code>@dp.message_handler()\nasync def any_text_message2(message: types.Message):\n    await message.answer(\n        text=f\"\u041f\u0440\u0438\u0432\u0435\u0442, &lt;b&gt;{fmt.quote_html(message.text)}&lt;/b&gt;\", \n        parse_mode=types.ParseMode.HTML\n    )\n    # Va bunday ham bo'lishi mumkin:\n    await message.answer(\n        text=fmt.text(\"\u041f\u0440\u0438\u0432\u0435\u0442,\", fmt.hbold(message.text)), \n        parse_mode=types.ParseMode.HTML\n    )\n</code></pre> <p></p> <p>Turli formatlash usullari va qo'llab-quvvatlanadigan teglar haqida batafsil ma'lumotni Bot API \"\u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f\"larida olishingiz mumkin.</p>"},{"location":"messages/#media","title":"Mediafayllar","text":"<p>Oddiy matnli xabarlardan tashqari Telegram sizga turli xil turdagi media fayllarni: fotosuratlar, videolar, giflar, geolokatsiyalar, stikerlar va boshqalarni almashish imkonini beradi. Aksariyat media fayllar <code>file_id</code> va <code>file_unique_id</code> parametrlariga ega. Birinchisi osha media faylni ko'p marta qayta yuborish uchun ishlatilish mumkin va jo'natish bir zumda bo'ladi, chunki faylning o'zi allaqachon Telegram serverlarida joylashgan bo'ladi. Va bu afzalliklaridan biri. Masalan, quyidagi kod botni foydalanuvchiga yuborilgan GIFga javob sifatida osha GIFni darhol yuboradi:</p> <pre><code>@dp.message_handler(content_types=[types.ContentType.ANIMATION])\nasync def echo_document(message: types.Message):\n    await message.reply_animation(message.animation.file_id)\n</code></pre> <p><code>file_id</code> har bir bot uchun unikal(unique - yagona)dir, ya'ni boshqa birovning fayl identifikatorini qayta ishlatish mumkin emas. Biroq, BotAPIda <code>fille_unique_id</code> ham mavjud. Uni Telegram aro qayta yuborish yoki yuklab olish uchun ishlatish mumkin emas, lekin u barcha botlarda bir xil. <code>file_unique_id</code> barcha chatlar uchun bir xil, oldin ushbu fayl bilan ishlanganmi yo'qmi bilish uchun qo'l keladi.</p> <p>Aytgancha, yuklab olish haqida: aiogram bot ishlayotgan serverga kichik fayllarni yuklash uchun qulay <code>download()</code> yordamchi metodini taklif qiladi:</p> <pre><code>@dp.message_handler(content_types=[types.ContentType.DOCUMENT])\nasync def download_doc(message: types.Message):\n    await message.document.download()\n\n\n# Kontent turlari ham turli yo'llar bilan belgilanishi mumkin.\n# ya'ni ham Enumlar yordamida ham string bilan:\n@dp.message_handler(content_types=[\"photo\"])\nasync def download_photo(message: types.Message):\n    # avval /tmp/somedir direktoriyasi mavjudligiga ishonch hosil qiling!\n    await message.photo[-1].download(destination=\"/tmp/somedir/\")\n</code></pre> <p>Rasmlar bilan ishlash</p> <p><code>message.photo[-1]</code> konstruktsiyasiga e'tibor bering. Foydalanuvchi botga rasm yuborganida, Telegram bitta obyektni emas, balki o\u2018sish tartibida tartiblangan rasmning turli o\u2018lchamdagi massivi(list)ni yuboradi. Biz listda oxirgi o'rinda turgan eng katta o'lchamdagi rasmga qiziqamiz (shuning uchun indeksga \"-1\").</p> <p>Katta hajmdagi fayllarni yuklab olish</p> <p>Telegram Bot APIdan foydalanadigan botlar 20 megabaytdan oshmaydigan fayllarni yuklab olishlari mumkin.</p> <p>Agar siz katta hajmdagi fayllarni yuklab olish/yuborishni rejalashtirmoqchi bo'lsangiz, Telegram Bot API emas, balki Telegram Client API bilan o'zaro aloqada bo'ladigan kutubxonalarni ko'rib chiqing, masalan, Telethon. Kam odam biladi, lekin Client APIdan nafaqat userbotlar, balki botlar ham yasashda foydalanish mumkin.</p> <p>Yaxshi yangilik, Bot API 5.0 versiyasidan boshlab siz katta fayllar bilan ishlash uchun o'zingizning Bot API serveringizdan foydalanishingiz mumkin. Ammo uni o'rnatish ko'proq resurslar talab qiladi.</p>"},{"location":"messages/#bonus","title":"Bonus","text":"<p>Rasm bilan birga uzun xabar yuborish kerak bo'lgan holatlar mavjud, ammo media fayllar uchun caption uzunligi cheklovi oddiy matnli xabarlar uchun 4096 bilan solishtirganda atigi 1024 belgidan iborat bo'lib, a matn oxiriga rasmga havola qo'yib-qo'yish xunuk ko'rinadi. Bundan tashqari, Telegram havolalarni oldindan parse qilib, meta teglarni o'qiydi (\u043f\u0440\u0435\u0434\u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440), natijada xabar siz kutgandek ko'rinmaydi.</p> <p>Ushbu muammoni hal qilish uchun ancha oldin HTML belgilashda \"yashirin havolalar\" ishlab chiqilgan. Xulosa shuki, siz havolani 0 kenglikdagi bo'sh joyga qo'yishingiz va butun tuzilmani (matn) boshiga kiritishingiz mumkin. Foydalanuvchi uchun xabarda havolalar yo'q va Telegram hamma narsani ko'radi (telagram ko'radi degani bu yuqoridagi aytib o'tilgan \"\u043f\u0440\u0435\u0434\u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\") va halollik bilan havoladagi rasmni qo'shib qo'yadi. Aiogram dasturchilari hatto buning uchun ham maxsus yordamchi util <code>hide_link()</code>ni yasab qo'yishgan:</p> <pre><code>import aiogram.utils.markdown as fmt\n\n@dp.message_handler(commands=\"test4\")\nasync def with_hidden_link(message: types.Message):\n    await message.answer(\n        f\"{fmt.hide_link('https://telegram.org/blog/video-calls/ru')}\u041a\u0442\u043e \u0431\u044b \u043c\u043e\u0433 \u043f\u043e\u0434\u0443\u043c\u0430\u0442\u044c, \u0447\u0442\u043e \"\n        f\"\u0432 2020 \u0433\u043e\u0434\u0443 \u0432 Telegram \u043f\u043e\u044f\u0432\u044f\u0442\u0441\u044f \u0432\u0438\u0434\u0435\u043e\u0437\u0432\u043e\u043d\u043a\u0438!\\n\\n\u041e\u0431\u044b\u0447\u043d\u044b\u0435 \u0433\u043e\u043b\u043e\u0441\u043e\u0432\u044b\u0435 \u0432\u044b\u0437\u043e\u0432\u044b \"\n        f\"\u0432\u043e\u0437\u043d\u0438\u043a\u043b\u0438 \u0432 Telegram \u043b\u0438\u0448\u044c \u0432 2017, \u0437\u0430\u043c\u0435\u0442\u043d\u043e \u043f\u043e\u0437\u0436\u0435 \u0441\u0432\u043e\u0438\u0445 \u043a\u043e\u043d\u043a\u0443\u0440\u0435\u043d\u0442\u043e\u0432. \u0410 \u0441\u043f\u0443\u0441\u0442\u044f \u0442\u0440\u0438 \u0433\u043e\u0434\u0430, \"\n        f\"\u043a\u043e\u0433\u0434\u0430 \u043e\u0433\u0440\u043e\u043c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043b\u044e\u0434\u0435\u0439 \u043d\u0430 \u043f\u043b\u0430\u043d\u0435\u0442\u0435 \u043f\u0440\u0438\u0443\u0447\u0438\u043b\u0438\u0441\u044c \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u0438\u0437 \u0434\u043e\u043c\u0430 \u0438\u0437-\u0437\u0430 \u044d\u043f\u0438\u0434\u0435\u043c\u0438\u0438 \"\n        f\"\u043a\u043e\u0440\u043e\u043d\u0430\u0432\u0438\u0440\u0443\u0441\u0430, \u043a\u043e\u043c\u0430\u043d\u0434\u0430 \u041f\u0430\u0432\u043b\u0430 \u0414\u0443\u0440\u043e\u0432\u0430 \u043d\u0435 \u0440\u0430\u0441\u0442\u0435\u0440\u044f\u043b\u0430\u0441\u044c \u0438 \u0441\u0434\u0435\u043b\u0430\u043b\u0430 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0435 \"\n        f\"\u0432\u0438\u0434\u0435\u043e\u0437\u0432\u043e\u043d\u043a\u0438 \u043d\u0430 WebRTC!\\n\\nP.S. \u0430 \u0435\u0449\u0451 \u0445\u043e\u0434\u044f\u0442 \u0441\u043b\u0443\u0445\u0438 \u043f\u0440\u043e \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u044e \u0441\u0432\u043e\u0435\u0433\u043e \u044d\u043a\u0440\u0430\u043d\u0430 :)\",\n        parse_mode=types.ParseMode.HTML\n    )\n</code></pre> <p></p> <p>Bu bobga yetadi. Keyingi boblargacha! Like bosing, Obuna bo'ling, Qo'ng'iroqchani bosib qo'ying</p>"},{"location":"quickstart/","title":"Aiogram bilan tanishuv","text":""},{"location":"quickstart/#installation","title":"O'rnatish","text":"<p>Birinchi bo'lib bot uchun \"\u043f\u0430\u043f\u043a\u0430\" yaratamiz, va u erda virtual muhit (venv) ochib, aktivlashtiramiz va aiogram kutubxonasini o'rnatamiz. Python 3.7 versiyasi o'rnatilganligini tekshirib ko'ramiz (agar sizda 3.8 yoki undan yuqori versiya o'rnatilganligini bilsangiz, bu qismni o'tkazib yuborishingiz mumkin):</p> <pre><code>[groosha@main lesson_01]$ python3.7\nPython 3.7.6 (default, Apr 27 2020, 00:17:38)\n[GCC 9.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; exit()\n[groosha@main lesson_01]$\n</code></pre> <p>Endi <code>requirements.txt</code> faylini yaratib, foydalanayotgan aiogram versiyasini kiritamiz.</p> <p>Aiogram versiyalari haqida</p> <p>Bu bobda aiogram 2.9.2 versiyasi qo\u2018llaniladi, lekin boshlashdan oldin kutubxonaning relizlar kanalini ko\u2018rib chiqishingizni va yangiroq versiyasini tekshirishingizni tavsiya qilaman. 2 raqami bilan boshlanadigan har qanday relizni ishlatishingiz mumkin, chunki aiogram 3.0 kelajakda sezilarli o'zgarishlar bilan va 2.Xga mos kelmaydigan darajada chiqarilishi kutilmoqda.</p> <p><pre><code>[groosha@main lesson_01]$ python3.7 -m venv venv\n[groosha@main lesson_01]$ echo \"aiogram==2.9.2\" &gt; requirements.txt\n[groosha@main lesson_01]$ source venv/bin/activate\n(venv) [groosha@main lesson_01]$ pip install -r requirements.txt\n# ...bu yerda installation haqida bir necha qatorlar...\nSuccessfully installed Babel-2.8.0 aiogram-2.9.2 aiohttp-3.6.2 async-timeout-3.0.1 attrs-19.3.0 certifi-2020.6.20 chardet-3.0.4 idna-2.10 multidict-4.7.6 pytz-2020.1 typing-extensions-3.7.4.2 yarl-1.5.1\nWARNING: You are using pip version 19.2.3, however version 20.2.1 is available.\nYou should consider upgrading via the 'pip install --upgrade pip' command.\n(venv) [groosha@main lesson_01]$\n</code></pre> Virtual muhitni aktivlashtirish: <code>source venv/bin/activate</code> - Linux Terminalda <code>venv\\Scripts\\activate</code> - Windows CMDda</p> <p>Terminaldagi <code>venv</code> prefiksiga e'tibor bering. Bu bizning <code>venv</code> nomli virtual muhitida ekanligimizdan dalolat beradi. Keling, venv ichida \"python\" buyrug'ini chaqiramiz (venv ichidagi python versiyasi ham global versiya bilan bir xil ekanligini ko'ramiz):</p> <pre><code>(venv) [groosha@main lesson_01]$ python\nPython 3.7.6 (default, Apr 27 2020, 00:17:38)\n[GCC 9.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; exit()\n(venv) [groosha@main lesson_01]$ deactivate\n[groosha@main lesson_01]$\n</code></pre> <p>Oxirgi <code>deactivate</code> buyrug'i bilan biz virtual muhitimizda chiqdik.</p>"},{"location":"quickstart/#hello-world","title":"Birinchi bot","text":"<p>Keling, basic aiogram bot shabloniga ega <code>bot.py</code> faylini yarataylik:</p> <pre><code>#!venv/bin/python\nimport logging\nfrom aiogram import Bot, Dispatcher, executor, types\n\n# Bot obyekti\nbot = Bot(token=\"12345678:AaBbCcDdEeFfGgHh\")\n# Bot dispetcheri\ndp = Dispatcher(bot)\n# Muhim xabarlarni loglarda o'tkazib yubormaslik uchun\nlogging.basicConfig(level=logging.INFO)\n\n\n# /test1 buyrug'i uchun handler (ishlovchi, boshqaruvchi)\n@dp.message_handler(commands=\"test1\")\nasync def cmd_test1(message: types.Message):\n    await message.reply(\"Test 1\")\n\n\nif __name__ == \"__main__\":\n    # Botni ishga tushirish\n    executor.start_polling(dp, skip_updates=True)\n</code></pre> <p>Shuni ta'kidlash kerakki, aiogram asinxron kutubxonadir, shuning uchun sizning funksiyalaringiz ham asinxron bo'lishi kerak, va API metodlariga qo'ng'iroq qilish (so'rov, chaqiruv)dan oldin siz await kalit so'zini qo'yishingiz kerak, chunki bu \"qo'ng'iroq\"lar korutinalar qaytaradi.</p> <p>Pythonda asinxron dasturlash</p> <p>Rasmiy \"\u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f\"larni e'tiborsiz qoldirmang! Python web-saytida asyncio uchun qo'llanma mavjud.</p> <p>Agar siz pyTelegramBotAPI kabi kutubxona bilan ishlagan bo'lsangiz, unda handler kontseptsiyasi sizga tanish, yagona farq shundaki, aiogramda handlerlar dispetcher tomonidan boshqariladi. Dispetcher handlerlar funksiyalarini ro'yxatdan o'tkazadi va ularni updatega qarab filtrlar orqali tartiblaydi mos kelmaydiganlarini ro'yxatdan olib tashlaydi. Qisqasi Telegramdan yangilanish (update) kelgach, qaysi handlerga borishi kerakligini tanlaydi. Filtrga misol: <code>\"chat_id X va rasm caption uzunligi Y bo'lgan xabarlarni qayta ishlash\"</code>.  </p> <p>Agar ikkita handler, bir xil mantiqiy filtrlarga ega bo'lsa, ro'yxatdan birinchi o'tgani chaqiriladi.</p> <p>Funksiyani handler sifatida ro'yxatdan o'tkazish uchun, ikki xil usul mavjud:</p> <ol> <li>Yuqoridagi misolda bo'lgani kabi, unga decorator biriktirish.</li> <li>To'g'ridan-to'g'ri dispetcherda ro'yxatdan o'tkazish.</li> </ol> <p>Quyidagi kodni ko'ring:</p> <pre><code># /test1 buyrug'i uchun decorator biriktirilgan handler\n@dp.message_handler(commands=\"test1\")\nasync def cmd_test1(message: types.Message):\n    await message.reply(\"Test 1\")\n\n# /test2 buyrug'i uchun handler\nasync def cmd_test2(message: types.Message):\n    await message.reply(\"Test 2\")\n</code></pre> <p>Keling, ular bilan botni ishga tushiramiz: </p> <p><code>/test2</code> buyrug'i uchun javobgar handler <code>cmd_test2</code> funksiyasi ishlamaydi, chunki dispetcher bu haqda bilmaydi. Keling, ushbu xatoni tuzatamiz va funksiyani ro'yxatdan o'tkazamiz:</p> <pre><code># /test2 buyrug'i uchun handler\nasync def cmd_test2(message: types.Message):\n    await message.reply(\"Test 2\")\n\n# Boshqa joyda...\ndp.register_message_handler(cmd_test2, commands=\"test2\")\n</code></pre> <p>Botni qayta ishga turshuramiz: </p>"},{"location":"quickstart/#error-handling","title":"Istisnolar bilan ishlash","text":"<p>Exception = Istisno</p> <p>Botning ishlashi davomida kod bilan emas, balki tashqi hodisalar bilan bog'liq bo'lgan turli xil xatolarning paydo bo'lishi muqarrar. Eng oddiy misol: botni bloklagan foydalanuvchiga xabar yuborishga urinish. Har bir metodni <code>try..except</code>ga tiqmaslik uchun aiogramda Bot API bilan bog'liq exceptionlar uchun maxsus handler mavjud. Quyidagi kodni ko'rib chiqing, u foydalanuvchiga javob berishdan oldin biroz uxlaydi:</p> <pre><code>@dp.message_handler(commands=\"block\")\nasync def cmd_block(message: types.Message):\n    await asyncio.sleep(10.0)  # 10 soniya sog'lom uyqu\n    await message.reply(\"Siz bloklandingiz.\")\n</code></pre> <p>Ushbu 10 soniya davomida foydalanuvchi botni bloklash uchun vaqt topishi mumkin va <code>reply</code> metodi chaqirilganida <code>BotBlocked</code> exceptioniga olib keladi. Keling, ushbu exception uchun maxsus handler yozamiz:</p> <pre><code>from aiogram.utils.exceptions import BotBlocked\n\n@dp.errors_handler(exception=BotBlocked)\nasync def error_bot_blocked(update: types.Update, exception: BotBlocked):\n    # Update: Telegramdan yangilanish obyekti. Exception: istisno obyekti\n\n    # Bu yerda siz blockni boshqarishingiz mumkin,\n    # masalan, foydalanuvchini bazadan o'chirish...\n    print(f\"Foydalanuvchi blokladi!\\nXabar: {update}\\nXatolik: {exception}\")\n\n    # Bunday handler har doim True qaytarishi kerak,\n    # agar qo'shimcha nimadir qilish kerak bo'lmasa.\n    return True\n</code></pre> <p>Bu handler boshqa handlerlarda yuzaga keladigan <code>BotBlocked</code> exceptionni bilan ishlaydi, natijada kod kamayadi, o'qilishi osonlashadi.</p> <p>Muhim</p> <p>Ammo xursandchiligimiz uzoqqa cho'zilmaydi, chunki <code>errors_handler</code>ning bir xususiyati borki, uni hamma Exceptionlarda ham foydalanish to'g'ri ish emas. Gap shundaki, exception uchun yozgan handleringiz ishga tushib va tugallangandan so'ng, boshqaruv asosiy xato yuzaga kelgan handlerga qaytmaydi. Oddiy qilib aytganda, agar, masalan, 100 ta siklning 57-iteratsiyasida <code>errors_handler</code>ni chaqirishiga to'g'ri kelsa (ya'ni exceptiion kelib chiqsa), qolgan iteratsiyalar va funksiyadagi kodning qolgan qismi bajarilmaydi. Bunday holatda, <code>try..except</code> ishlatishdan boshqa hech narsa qolmaydi.</p>"},{"location":"quickstart/#sugar","title":"Sintaktik shakar","text":"<p>Kodni yanada toza yozilishi va o'qilishi uchun aiogram standart Telegram metodlarining imkoniyatlarini kengaytirgan. Masalan, <code>bot.send_message(...)</code> o'rniga <code>message.answer(...)</code> yoki <code>message.reply(...)</code> yozishingiz mumkin. Oxirgi ikki holatda <code>chat_id</code>ni ko'rsatish shart emas, u <code>updade</code>dan o'zi oladi. <code>answer</code> va <code>reply</code> o'rtasidagi farq oddiy: Birinchi metod shunchaki chatga xabar yuboradi, ikkinchisi xabarga javob qaytaradi:</p> <pre><code>@dp.message_handler(commands=\"answer\")\nasync def cmd_answer(message: types.Message):\n    # bu xabar yuboradi\n    await message.answer(\"\u042d\u0442\u043e \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\")\n\n\n@dp.message_handler(commands=\"reply\")\nasync def cmd_reply(message: types.Message):\n    # bu xabarga javob qaytaradi\n    await message.reply('\u042d\u0442\u043e \u043e\u0442\u0432\u0435\u0442 \u0441 \"\u043e\u0442\u0432\u0435\u0442\u043e\u043c\"')\n</code></pre> <p></p> <p>Bundan tashqari, ko'pgina xabar turlari uchun <code>answer_{type}</code> yoki <code>reply_{type}</code> kabi yordamchi metodlar mavjud, ya'ni <code>.answer_photo(...)</code> yoki <code>.reply_video(...)</code> masalan:</p> <pre><code>@dp.message_handler(commands=\"dice\")\nasync def cmd_dice(message: types.Message):\n    await message.answer_dice(emoji=\"\ud83c\udfb2\")\n</code></pre> <p>'message: types.Message' nimani anglatadi ?</p> <p>Python - kuchli ammo dinamik turlanishga ega bo'lgan interpretor til, shuning uchun C++ yoki Javadagi kabi avvaldan ma'lum bir o'zgaruvchiga uni turini belgilab qo'yish mavjud emas. Biroq, 3.5-versiyadan boshlab, pythondagi variablelar turlariga \"hint(\u043f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0430)\"lar berishni qo'llab-quvvatlashni boshladi, buning natijasida PyCharm kabi turli \"checker\" va IDElar variablelar turlarini tahlil qiladi va dasturchiga biror narsa noto'g'ri bo'lsa, xabar beradi. Bizning holatda, <code>types.Message</code> hint(ko'rsatmasi) PyCharm\u2019ga <code>message</code> o\u2018zgaruvchisi aiogram kutubxonasining <code>types</code> modulida aniqlanganidek <code>Message</code> turida ekanligini bildiradi (kod boshida importga qarang). Bu IDEga atributlar va funksiyalarni tezda taklif qilish imkonini beradi.</p> <p><code>/dice</code> buyrug'ini chaqirganda, bot o'sha chatga dice(\ud83c\udfb2) yuboradi. Albatta, agar siz uni boshqa chatga yuborishingiz kerak bo\u2018lsa, eski uslubda <code>await bot.send_dice(...)</code>ga murojaat qilishingiz kerak bo\u2018ladi. Lekin <code>bot</code> obyekti (Bot classining ekzemplyari) ma'lum bir funksiyangiz bor modulda mavjud bo'lmasligi mumkin, ya'ni botingizni shabloniga asoslansak, <code>bot</code> obyekti ishga tushuruvchi fayldagina bo'ladi. Yaxshiyamki, bot obyekti barcha turdagi updatelarda mavjud: Message, CallbackQuery, InlineQuery va boshqalarda. Aytaylik, siz <code>/dice</code> buyrug'i yordamida \ud83c\udfb2ni suhbatlashiyotgan chatga emas, balki IDsi -100123456789 bo'lgan kanalga yubormoqchisiz. Oldingi funksiyani qayta yozamiz:</p> <pre><code>@dp.message_handler(commands=\"dice\")\nasync def cmd_dice(message: types.Message):\n    await message.bot.send_dice(-100123456789, emoji=\"\ud83c\udfb2\")\n</code></pre> <p>Hammasi yaxshi, lekin agar siz to'satdan kodni kimdir bilan baham ko'rmoqchi bo'lsangiz, har safar bot tokenini koddan olib tashlashingiz kera, aks holda uni @BotFather bilan qayta <code>/revoke</code> qilishingizga to'g'ri keladi. Xavfsizlik uchun tokenni to'g'ridan-to'g'ri kodda ko'rsatishni to'xtataylik endi, uni virtual-muhit o'zgaruvchisi sifatida chiqaraylik. Fayl boshidagi quyidagi qatorlarni:</p> <pre><code>import logging\nfrom aiogram import Bot, Dispatcher, executor, types\n\nbot = Bot(token=\"12345678:AaBbCcDdEeFfGgHh\")\n</code></pre> <p>bunga almashtiring:</p> <pre><code>import logging\nfrom aiogram import Bot, Dispatcher, executor, types\nfrom os import getenv\nfrom sys import exit\n\nbot_token = getenv(\"BOT_TOKEN\")\nif not bot_token:\n    exit(\"Error: no token provided\")\n\nbot = Bot(token=bot_token)\n</code></pre> <p>Ammo endi sizning botingiz ishga tushmaydi. <code>Error: no token provided</code> bilan darhol ishini to'xtatadi. PyCharmga virtual muhit o'zgaruvchisini kiritish uchun yuqoridagi Run -&gt; Edit Configurations bo'limini oching va Environment Variables oynasiga BOT_TOKEN nomi va token qiymati bilan yangi o'zgaruvchini qo'shing.</p> <p></p> <p>Botni qayta ishga tushirib, ishlayotganiga kayf qiling. Kodni PyCharmda qo'rqmasdan File Templatesda saqlash mumkin.</p> <p>Kutubxona bilan tanishuvimizni shu yerda yakunlaymiz va keyingi boblarda aiogram va Telegram Bot APIning boshqa \"features\"larini ko\u2018rib chiqamiz.</p>"}]}